export const pagesRoutes = [
  ["v-8daa1a0e","/",{"y":"h","t":"主页","i":"home"},["/index.html","/README.md"]],
  ["v-184f4da6","/intro.html",{"d":"2022-9-12","l":"2022年9月12日","e":"<h1> 个人简介</h1>\n<ul>\n<li>\n<p>男</p>\n</li>\n<li>\n<p>近而立之年</p>\n</li>\n<li>\n<p>iOS/前端开发</p>\n</li>\n<li>\n<p>杰伦音乐忠实听众</p>\n</li>\n<li>\n<p>篮球痴迷孤独患者</p>\n</li>\n<li>\n<p>英语盲目练习角色</p>\n</li>\n<li>\n<p>健身佛系坚持人员</p>\n</li>\n</ul>\n","y":"a","t":"个人简介"},["/intro","/intro.md"]],
  ["v-f915a88a","/%E9%9A%8F%E8%AE%B0/1.html",{"d":"2021-02-26T00:00:00.000Z","l":"2021年2月26日","e":"<h1> 人生是一场循环</h1>\n<p>人生或许是一场循环吧。<br></p>\n<p>当闭上双眼、停止呼吸、老去的下一刻，迷迷蒙蒙我的意识又一次回到了妈妈的子宫内。<br></p>\n<p>再次出生、再次来到孩提、再次重复过去所发生的一切，再次重复未来将要发生的一切。<br></p>\n<p>如果真是这样，我会是多么的愧疚。<br></p>\n<p>我为自己曾经说过的那些伤人的话深深愧疚，为自己不懂得珍惜友情爱情而深深愧疚，为为我付出过的我却心安理得接受的一切深深愧疚。<br></p>\n<p>然而，<br>\n如果未来和过去真的只是重复地在走这一生，我又何必如此。<br></p>\n<p>何不从现在开始，让一切努力美好开心起来，做一个小太阳、给周围和未来带来正能量。</p>","y":"a","t":"人生是一场循环"},["/随记/1.html","/%E9%9A%8F%E8%AE%B0/1","/随记/1.md","/%E9%9A%8F%E8%AE%B0/1.md"]],
  ["v-f5abf74c","/%E9%9A%8F%E8%AE%B0/2.html",{"d":"2019-07-23T00:00:00.000Z","l":"2019年7月23日","e":"<h1> 暑思</h1>\n<p>行香子·暑思</p>\n<p>流火如烛，映水边柳。照我眠、子规啾啾。<br>\n梦回旧时，明月何有。向望海楼，金牛岭，陆水舟。<br></p>\n<p>怡然偷乐，故地神游。待得醒、流水依旧。<br>\n逝者如斯，故人知否。但昨日休，今日静，明日悠。</p>\n","y":"a","t":"暑思"},["/随记/2.html","/%E9%9A%8F%E8%AE%B0/2","/随记/2.md","/%E9%9A%8F%E8%AE%B0/2.md"]],
  ["v-f242460e","/%E9%9A%8F%E8%AE%B0/3.html",{"d":"2018-10-11T00:00:00.000Z","l":"2018年10月11日","e":"<h1> 三年了</h1>\n<p>午后的阳光慵懒、僵硬，傍晚的冷气让人清醒。<br></p>\n<p>慵懒和清醒之间的，是球场上来回的沸腾的身影。<br></p>\n<p>那我第一次来这儿。<br></p>\n<p>三年前的我，只怕没有燃烧过。<br></p>\n<p>一切历历可数。<br></p>\n<p>然而记忆犹新的又怎么会只是三年前。<br></p>\n<p>人生就像一张铺开了的网，我顺着网线在这片大网上踽踽前行。<br></p>\n<p>多少网孔被留在了身后，那些是我再也无法填平的缺憾。<br></p>\n<p>即使打上了结，脑海里无数次的翻阅，也无法顺着回忆的线回到从前了。</p>\n","y":"a","t":"三年了"},["/随记/3.html","/%E9%9A%8F%E8%AE%B0/3","/随记/3.md","/%E9%9A%8F%E8%AE%B0/3.md"]],
  ["v-eed894d0","/%E9%9A%8F%E8%AE%B0/4.html",{"d":"2022-01-08T00:00:00.000Z","l":"2022年1月8日","e":"<h1> “沉重”话题</h1>\n<p>说个“沉重”的话题，关于瘦肚子。<br></p>\n<p>很多人发现练腹肌自己坚持了很久并没有什么用，之前也有同事说连续做了快两年仰卧起坐肚子上还是很多肉问我原因。<br></p>\n<p>也有老同学几年间问了我好多次，然而还是没有瘦下来，一个是理解偏差，还有一个是执行力问题。<br></p>\n<p>最关键的先放在前面：不要做仰卧起坐了，腰部不要借力，腰肌劳损腰膨腰突压迫神经什么的迟早会找上门。<br></p>\n<p>第一个是增加腹肌，是平时大家做的各种卷腹举腿核心训练对应的训练目的，这类锻炼确实可以增加腹肌量，但是热量消耗并不大。<br></p>\n<p>第二个是练腹肌是不会掉肚子上的脂肪，脂肪和肌肉不同物质不会直接转换，也不可能单独减身体某个部位的脂肪，减脂就是需要热量赤字也就是消耗热量大于摄取热量。<br></p>","y":"a","t":"“沉重”话题"},["/随记/4.html","/%E9%9A%8F%E8%AE%B0/4","/随记/4.md","/%E9%9A%8F%E8%AE%B0/4.md"]],
  ["v-eb6ee392","/%E9%9A%8F%E8%AE%B0/5.html",{"d":"2023-03-01T00:00:00.000Z","l":"2023年3月1日","c":[],"g":[],"e":"<h1> 妈妈</h1>\n<p>劝妈妈出来玩可不是容易的事，吐槽来回车费多贵，说自己身体多好不需要公司的福利体检。<br></p>\n<p>很多年轻人早已气喘吁吁，而近六旬的妈妈在长城最高点气定神闲，想起妈妈当年为讨生活，年复一年的风里来雪里去，或许这就是她体力如此好、满满当当四天跟我去了十几个景点的原因。<br></p>\n<p>妈妈以前似乎从没有进过动物园，记忆里的妈妈在动物园外边等大家出来，说门票那么贵也没什么好看的自己就不进去了。而那时候的她比起现在的我也大不了几岁。<br></p>\n<p>站在清华北大门口，妈妈开心地像个孩子。参观历史展览，她会一行行一幅幅读地仔仔细细。听人说成绩优异的妈妈当年无奈辍学精神上承受了很多。不是她我也早已辍学，她从来无暇顾及自己的伤疤。回想班主任跟我的谈话，我知道他从来没有见过这么坚定的父母。<br></p>","y":"a","t":"妈妈"},["/随记/5.html","/%E9%9A%8F%E8%AE%B0/5","/随记/5.md","/%E9%9A%8F%E8%AE%B0/5.md"]],
  ["v-56280bb9","/%E5%BC%80%E5%8F%91/%E3%80%8EOther%E3%80%8F/1.html",{"d":"2020-08-09T00:00:00.000Z","l":"2020年8月9日","c":["iOS"],"e":"<h1> 一些规范</h1>\n<p>iOS开发中，规范的编码方式和风格可以使代码更加清晰易读、易于维护。</p>\n<h2> 代码组织</h2>\n<h3> 文件名</h3>\n<ul>\n<li>文件名应该清晰明了，使用驼峰命名法，以首字母大写的类名为准。</li>\n<li>对于 UIKit 和 Foundation 框架提供的类的扩展，应该以 + 为前缀，例如 String+Extension.swift。</li>\n</ul>\n<h3> 代码结构</h3>\n<ul>\n<li>文件应该按照逻辑组织代码，不要将过多的代码放在一个文件中。</li>\n<li>import 应该按照字母顺序排列，分组放置。系统框架应该在第一组。</li>\n<li>代码应该按照生命周期的顺序进行编写：先是属性和初始化方法，接着是 viewDidLoad()，然后是其他的生命周期方法，最后是自定义的方法。</li>\n</ul>","y":"a","t":"一些规范"},["/开发/『Other』/1.html","/%E5%BC%80%E5%8F%91/%E3%80%8EOther%E3%80%8F/1","/开发/『Other』/1.md","/%E5%BC%80%E5%8F%91/%E3%80%8EOther%E3%80%8F/1.md"]],
  ["v-57dce458","/%E5%BC%80%E5%8F%91/%E3%80%8EOther%E3%80%8F/2.html",{"d":"2021-08-10T00:00:00.000Z","l":"2021年8月10日","c":["iOS"],"e":"<h1> 审核被拒</h1>\n<p>iOS 应用审核是苹果公司对于在 App Store 上发布的应用进行的一项重要检查。苹果公司会检查应用是否符合规定的政策和准则，包括内容、功能、安全性等方面。通过审核后应用才能被发布并供用户下载使用。然而提交应用时都会遇到各种审核问题，这些问题可能会导致应用被拒绝。</p>\n<h2> H5占比太高</h2>\n<ul>\n<li>整体应用修改，增加原生功能内容，降低H5占比，否则无法过审。</li>\n</ul>\n<h2> 内置H5游戏被拒</h2>\n<ul>\n<li>需提交相关资料证明该 H5 游戏的开发者是苹果开发者</li>\n</ul>\n<h2> 设计与App Store版面相像以及跟应用分发类型应用相像被拒</h2>","y":"a","t":"审核被拒"},["/开发/『Other』/2.html","/%E5%BC%80%E5%8F%91/%E3%80%8EOther%E3%80%8F/2","/开发/『Other』/2.md","/%E5%BC%80%E5%8F%91/%E3%80%8EOther%E3%80%8F/2.md"]],
  ["v-5991bcf7","/%E5%BC%80%E5%8F%91/%E3%80%8EOther%E3%80%8F/3.html",{"d":"2019-9-11","l":"2019年9月11日","c":["iOS"],"e":"<h1> cocoapods简介</h1>\n<p>CocoaPods是一个针对iOS和Mac开发的依赖管理器，可以帮助开发者快速、简便地管理项目中的依赖关系。</p>\n<h2> cocoapods安装</h2>\n<p>在终端中运行以下命令安装CocoaPods：</p>\n<div class=\"language-ruby line-numbers-mode\" data-ext=\"rb\"><pre class=\"language-ruby\"><code>$ sudo gem install cocoapods\n</code></pre><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div>","y":"a","t":"cocoapods简介"},["/开发/『Other』/3.html","/%E5%BC%80%E5%8F%91/%E3%80%8EOther%E3%80%8F/3","/开发/『Other』/3.md","/%E5%BC%80%E5%8F%91/%E3%80%8EOther%E3%80%8F/3.md"]],
  ["v-5b469596","/%E5%BC%80%E5%8F%91/%E3%80%8EOther%E3%80%8F/4.html",{"d":"2022-8-12","l":"2022年8月12日","c":["iOS"],"e":"<h1> Fastlane简介</h1>\n<p><a href=\"https://fastlane.tools/\" target=\"_blank\" rel=\"noopener noreferrer\">Fastlane</a>是一个流行的用于iOS和Android应用程序自动化构建和发布的自动化打包工具。它可以帮助你自动执行各种任务，例如编译代码、打包应用程序、生成屏幕截图、发布应用程序等等。</p>\n<h2> 安装Fastlane</h2>\n<h3> 安装Xcode和命令行工具</h3>\n<p>Fastlane需要Xcode和命令行工具来工作。如果你还没有安装Xcode和命令行工具，请先在App Store中安装Xcode，并在终端中运行以下命令安装命令行工具：</p>","y":"a","t":"Fastlane简介"},["/开发/『Other』/4.html","/%E5%BC%80%E5%8F%91/%E3%80%8EOther%E3%80%8F/4","/开发/『Other』/4.md","/%E5%BC%80%E5%8F%91/%E3%80%8EOther%E3%80%8F/4.md"]],
  ["v-0da6f331","/%E5%BC%80%E5%8F%91/%E3%80%8ESwiftUI%E3%80%8F/0.html",{"d":"2022-5-04","l":"2022年5月4日","c":["iOS","Swift","SwiftUI"],"e":"<h1> 00.官方教程读后记录</h1>\n<h2> <a href=\"https://developer.apple.com/tutorials/swiftui\" target=\"_blank\" rel=\"noopener noreferrer\">官方教程</a></h2>\n<p>以下是整理的一些注意点：</p>\n<ul>\n<li>声明式编程风格，可以简化UI的创建和管理</li>\n</ul>\n<blockquote>\n<p>相比传统的imperative编程风格，SwiftUI能够更好地表达开发者的意图，并且代码更易于阅读和维护。</p>\n</blockquote>\n<ul>\n<li>提供许多原生视图和容器</li>\n</ul>","y":"a","t":"00.官方教程读后记录"},["/开发/『SwiftUI』/0.html","/%E5%BC%80%E5%8F%91/%E3%80%8ESwiftUI%E3%80%8F/0","/开发/『SwiftUI』/0.md","/%E5%BC%80%E5%8F%91/%E3%80%8ESwiftUI%E3%80%8F/0.md"]],
  ["v-0f5bcbd0","/%E5%BC%80%E5%8F%91/%E3%80%8ESwiftUI%E3%80%8F/1.html",{"d":"2022-5-06","l":"2022年5月6日","c":["iOS","Swift","SwiftUI"],"e":"<h1> 01.概述</h1>\n<p>SwiftUI 是苹果公司推出的一款全新的 UI 开发框架，旨在为开发者提供更加现代化、易于使用的界面设计工具，以及更加高效和简洁的代码编写方式。<br>\nSwiftUI 引入了一系列新的语法和组件，使得开发者可以更加轻松地构建复杂的用户界面，同时也大大提升了应用程序的性能和交互体验。<br>\nSwiftUI 的主要特点如下：</p>\n<h2> 声明式语法</h2>\n<p>SwiftUI 采用了声明式语法，使得开发者可以更加方便地描述应用程序的用户界面。开发者只需要定义所需的组件和布局方式，而不必关心具体的实现细节。相比传统的命令式编程方式，声明式语法更加简洁、易于维护和扩展。<br>\n声明式语法创建一个简单的按钮：</p>","y":"a","t":"01.概述"},["/开发/『SwiftUI』/1.html","/%E5%BC%80%E5%8F%91/%E3%80%8ESwiftUI%E3%80%8F/1","/开发/『SwiftUI』/1.md","/%E5%BC%80%E5%8F%91/%E3%80%8ESwiftUI%E3%80%8F/1.md"]],
  ["v-475e9adc","/%E5%BC%80%E5%8F%91/%E3%80%8ESwiftUI%E3%80%8F/10.html",{"d":"2022-8-12","l":"2022年8月12日","c":["iOS","Swift","SwiftUI"],"g":["UI","交互"],"e":"<h1> 10.手势</h1>\n<p>在SwiftUI中，可以通过手势识别器（Gesture Recognizers）来捕捉和响应用户的手势操作。SwiftUI提供了一些内置的手势识别器，例如拖动手势、轻击手势、长按手势等，同时也支持自定义手势识别器。</p>\n<h2> 内置手势识别器</h2>\n<p>SwiftUI提供了多种内置手势识别器，可以通过视图修饰符.gesture()来添加手势识别器。常见的内置手势识别器有：</p>\n<ul>\n<li>TapGesture：轻击手势，可以设置点击次数、手指数等属性。</li>\n<li>LongPressGesture：长按手势，可以设置最短持续时间、最大移动距离等属性。</li>\n<li>DragGesture：拖动手势，可以设置最大/最小拖动速度、拖动方向等属性。</li>\n<li>MagnificationGesture：放大/缩小手势，可以设置最小/最大放大比例等属性。</li>\n<li>RotationGesture：旋转手势，可以设置最小/最大旋转角度等属性。</li>\n</ul>","y":"a","t":"10.手势"},["/开发/『SwiftUI』/10.html","/%E5%BC%80%E5%8F%91/%E3%80%8ESwiftUI%E3%80%8F/10","/开发/『SwiftUI』/10.md","/%E5%BC%80%E5%8F%91/%E3%80%8ESwiftUI%E3%80%8F/10.md"]],
  ["v-43f4e99e","/%E5%BC%80%E5%8F%91/%E3%80%8ESwiftUI%E3%80%8F/11.html",{"d":"2022-9-15","l":"2022年9月15日","c":["iOS","Swift","SwiftUI"],"g":["UI"],"e":"<h1> 11.容器视图</h1>\n<p>容器视图是 SwiftUI 中的一个重要组成部分，它们用于组合和管理其他视图，从而创建出复杂的用户界面。</p>\n<h2> 常见的容器视图</h2>\n<p>SwiftUI 中有很多种容器视图，每种容器视图都有不同的用途和特点。下面是一些常见的容器视图：</p>\n<h3> VStack 和 HStack</h3>\n<p>VStack 和 HStack 都用于将多个视图按垂直或水平方向排列。VStack 将视图从上到下排列，而 HStack 将视图从左到右排列。这两种容器视图都支持对子视图的对齐方式、间距、填充等样式的设置。</p>\n<h3> ZStack</h3>","y":"a","t":"11.容器视图"},["/开发/『SwiftUI』/11.html","/%E5%BC%80%E5%8F%91/%E3%80%8ESwiftUI%E3%80%8F/11","/开发/『SwiftUI』/11.md","/%E5%BC%80%E5%8F%91/%E3%80%8ESwiftUI%E3%80%8F/11.md"]],
  ["v-408b3860","/%E5%BC%80%E5%8F%91/%E3%80%8ESwiftUI%E3%80%8F/12.html",{"d":"2022-9-28","l":"2022年9月28日","c":["iOS","Swift","SwiftUI"],"g":["UI"],"e":"<h1> 12.导航视图</h1>\n<p>导航视图是 SwiftUI 中非常重要的一个组件，它可以用于管理应用程序中的多个视图。</p>\n<h2> 导航视图的基础</h2>\n<p>在 SwiftUI 中，导航视图可以通过 NavigationView 和 NavigationLink 两个组件来实现。其中，NavigationView 用于包含和管理多个视图，而 NavigationLink 用于在不同的视图之间进行切换。</p>\n<h3> NavigationView</h3>\n<p>NavigationView 是一个容器视图，它可以包含多个视图，并将这些视图按照导航栏和工具栏的形式进行显示。当用户选择导航栏中的某个项目时，NavigationView 会自动将对应的视图进行显示。<br></p>","y":"a","t":"12.导航视图"},["/开发/『SwiftUI』/12.html","/%E5%BC%80%E5%8F%91/%E3%80%8ESwiftUI%E3%80%8F/12","/开发/『SwiftUI』/12.md","/%E5%BC%80%E5%8F%91/%E3%80%8ESwiftUI%E3%80%8F/12.md"]],
  ["v-3d218722","/%E5%BC%80%E5%8F%91/%E3%80%8ESwiftUI%E3%80%8F/13.html",{"d":"2022-10-02T00:00:00.000Z","l":"2022年10月2日","c":["iOS","Swift","SwiftUI"],"g":["UI"],"e":"<h1> 13.列表视图</h1>\n<p>在 SwiftUI 中，列表视图是一个非常重要的组件，可以用于显示数据列表、菜单、选项卡等。<br></p>\n<p>SwiftUI 中的列表视图，包括 List 和 ForEach 两个组件的基本用法和高级用法。我们将通过一个示例来演示如何使用列表视图显示数据列表，并在列表项中添加图像、文本和交互控件。</p>\n<h2> List 组件</h2>\n<p>List 组件是 SwiftUI 中的列表视图，可以用于显示数据列表。List 组件需要一个数据源和一个内容视图，其中数据源用于提供列表数据，内容视图用于定义列表项的布局和样式。例如，我们可以使用 List 组件来显示一个简单的字符串数组：</p>","y":"a","t":"13.列表视图"},["/开发/『SwiftUI』/13.html","/%E5%BC%80%E5%8F%91/%E3%80%8ESwiftUI%E3%80%8F/13","/开发/『SwiftUI』/13.md","/%E5%BC%80%E5%8F%91/%E3%80%8ESwiftUI%E3%80%8F/13.md"]],
  ["v-39b7d5e4","/%E5%BC%80%E5%8F%91/%E3%80%8ESwiftUI%E3%80%8F/14.html",{"d":"2022-10-05T00:00:00.000Z","l":"2022年10月5日","c":["iOS","Swift","SwiftUI"],"g":["UI"],"e":"<h1> 14.表单视图</h1>\n<p>表单视图在 iOS 应用程序中是一种常见的用户界面组件，可以用于收集用户的输入或设置应用程序的选项。在 SwiftUI 中，表单视图是通过一个名为 Form 的容器视图来实现的，它提供了许多内置的表单元素，如文本字段、开关、选择器等。<br></p>\n<h2> 创建表单视图</h2>\n<p>要创建一个表单视图，我们只需将所有表单元素放入 Form 容器中即可。以下是一个简单的示例：</p>\n<div class=\"language-swift line-numbers-mode\" data-ext=\"swift\"><pre class=\"language-swift\"><code><span class=\"token keyword\">struct</span> <span class=\"token class-name\">ContentView</span><span class=\"token punctuation\">:</span> <span class=\"token class-name\">View</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> body<span class=\"token punctuation\">:</span> <span class=\"token keyword\">some</span> <span class=\"token class-name\">View</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token class-name\">Form</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token class-name\">Text</span><span class=\"token punctuation\">(</span><span class=\"token string-literal\"><span class=\"token string\">\"Hello, World!\"</span></span><span class=\"token punctuation\">)</span>\n            <span class=\"token class-name\">TextField</span><span class=\"token punctuation\">(</span><span class=\"token string-literal\"><span class=\"token string\">\"Enter your name\"</span></span><span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">.</span><span class=\"token function\">constant</span><span class=\"token punctuation\">(</span><span class=\"token string-literal\"><span class=\"token string\">\"\"</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n            <span class=\"token class-name\">Toggle</span><span class=\"token punctuation\">(</span><span class=\"token string-literal\"><span class=\"token string\">\"Show advanced options\"</span></span><span class=\"token punctuation\">,</span> isOn<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">.</span><span class=\"token function\">constant</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n            <span class=\"token class-name\">Button</span><span class=\"token punctuation\">(</span><span class=\"token string-literal\"><span class=\"token string\">\"Submit\"</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token comment\">// Submit the form</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>","y":"a","t":"14.表单视图"},["/开发/『SwiftUI』/14.html","/%E5%BC%80%E5%8F%91/%E3%80%8ESwiftUI%E3%80%8F/14","/开发/『SwiftUI』/14.md","/%E5%BC%80%E5%8F%91/%E3%80%8ESwiftUI%E3%80%8F/14.md"]],
  ["v-364e24a6","/%E5%BC%80%E5%8F%91/%E3%80%8ESwiftUI%E3%80%8F/15.html",{"d":"2022-10-05T00:00:00.000Z","l":"2022年10月5日","c":["iOS","Swift","SwiftUI"],"g":["语法"],"e":"<h1> 15.数据模型和数据管理</h1>\n<p>SwiftUI中可以使用数据模型来表示应用程序的数据，并使用数据管理来更新和传递这些数据。</p>\n<h2> 数据模型</h2>\n<p>数据模型是应用程序中的数据结构。它定义了应用程序使用的数据类型，并确定数据之间的关系。可以使用Swift语言中的结构体来定义数据模型。<br></p>\n<p>下面是一个简单的示例：</p>\n<div class=\"language-swift line-numbers-mode\" data-ext=\"swift\"><pre class=\"language-swift\"><code><span class=\"token keyword\">struct</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">:</span> <span class=\"token class-name\">Identifiable</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> id <span class=\"token operator\">=</span> <span class=\"token function\">UUID</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">var</span> name<span class=\"token punctuation\">:</span> <span class=\"token class-name\">String</span>\n    <span class=\"token keyword\">var</span> age<span class=\"token punctuation\">:</span> <span class=\"token class-name\">Int</span>\n<span class=\"token punctuation\">}</span>\n</code></pre><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>","y":"a","t":"15.数据模型和数据管理"},["/开发/『SwiftUI』/15.html","/%E5%BC%80%E5%8F%91/%E3%80%8ESwiftUI%E3%80%8F/15","/开发/『SwiftUI』/15.md","/%E5%BC%80%E5%8F%91/%E3%80%8ESwiftUI%E3%80%8F/15.md"]],
  ["v-32e47368","/%E5%BC%80%E5%8F%91/%E3%80%8ESwiftUI%E3%80%8F/16.html",{"d":"2022-11-17T00:00:00.000Z","l":"2022年11月17日","c":["iOS","Swift","SwiftUI"],"g":["网络"],"e":"<h1> 16.网络请求和数据解析</h1>\n<p>SwiftUI提供了一些强大的工具来执行网络请求和解析响应数据。</p>\n<h2> 发送网络请求</h2>\n<p>SwiftUI中提供了URLSession API来发送网络请求。<br>\n下面是一个示例，展示如何使用URLSession API发送GET请求：</p>\n<div class=\"language-swift line-numbers-mode\" data-ext=\"swift\"><pre class=\"language-swift\"><code><span class=\"token keyword\">struct</span> <span class=\"token class-name\">ContentView</span><span class=\"token punctuation\">:</span> <span class=\"token class-name\">View</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token attribute atrule\">@State</span> <span class=\"token keyword\">private</span> <span class=\"token keyword\">var</span> posts<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token class-name\">Post</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n\n    <span class=\"token keyword\">var</span> body<span class=\"token punctuation\">:</span> <span class=\"token keyword\">some</span> <span class=\"token class-name\">View</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token class-name\">List</span><span class=\"token punctuation\">(</span>posts<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> post <span class=\"token keyword\">in</span>\n            <span class=\"token class-name\">Text</span><span class=\"token punctuation\">(</span>post<span class=\"token punctuation\">.</span>title<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">.</span>onAppear <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">guard</span> <span class=\"token keyword\">let</span> url <span class=\"token operator\">=</span> <span class=\"token function\">URL</span><span class=\"token punctuation\">(</span>string<span class=\"token punctuation\">:</span> <span class=\"token string-literal\"><span class=\"token string\">\"https://url.com/posts\"</span></span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">return</span> <span class=\"token punctuation\">}</span>\n\n            <span class=\"token class-name\">URLSession</span><span class=\"token punctuation\">.</span>shared<span class=\"token punctuation\">.</span><span class=\"token function\">dataTask</span><span class=\"token punctuation\">(</span>with<span class=\"token punctuation\">:</span> url<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> data<span class=\"token punctuation\">,</span> response<span class=\"token punctuation\">,</span> error <span class=\"token keyword\">in</span>\n                <span class=\"token keyword\">guard</span> <span class=\"token keyword\">let</span> data <span class=\"token operator\">=</span> data<span class=\"token punctuation\">,</span> error <span class=\"token operator\">==</span> <span class=\"token nil constant\">nil</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token function\">print</span><span class=\"token punctuation\">(</span>error<span class=\"token operator\">?</span><span class=\"token punctuation\">.</span>localizedDescription <span class=\"token operator\">??</span> <span class=\"token string-literal\"><span class=\"token string\">\"Unknown error\"</span></span><span class=\"token punctuation\">)</span>\n                    <span class=\"token keyword\">return</span>\n                <span class=\"token punctuation\">}</span>\n\n                <span class=\"token keyword\">let</span> decoder <span class=\"token operator\">=</span> <span class=\"token class-name\">JSONDecoder</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n                <span class=\"token keyword\">if</span> <span class=\"token keyword\">let</span> decodedData <span class=\"token operator\">=</span> <span class=\"token keyword\">try</span><span class=\"token operator\">?</span> decoder<span class=\"token punctuation\">.</span><span class=\"token function\">decode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token class-name\">Post</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">,</span> from<span class=\"token punctuation\">:</span> data<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token class-name\">DispatchQueue</span><span class=\"token punctuation\">.</span>main<span class=\"token punctuation\">.</span><span class=\"token keyword\">async</span> <span class=\"token punctuation\">{</span>\n                        <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>posts <span class=\"token operator\">=</span> decodedData\n                    <span class=\"token punctuation\">}</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span><span class=\"token punctuation\">.</span><span class=\"token function\">resume</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>","y":"a","t":"16.网络请求和数据解析"},["/开发/『SwiftUI』/16.html","/%E5%BC%80%E5%8F%91/%E3%80%8ESwiftUI%E3%80%8F/16","/开发/『SwiftUI』/16.md","/%E5%BC%80%E5%8F%91/%E3%80%8ESwiftUI%E3%80%8F/16.md"]],
  ["v-1110a46f","/%E5%BC%80%E5%8F%91/%E3%80%8ESwiftUI%E3%80%8F/2.html",{"d":"2022-5-08","l":"2022年5月8日","c":["iOS","Swift","SwiftUI"],"e":"<h1> 02.项目初始化</h1>\n<h2> 创建项目</h2>\n<ul>\n<li>\n<p>创建新项目\n在 Xcode 中，选择 \"Create a new Xcode project\"。然后，在弹出窗口中，选择 \"iOS\" 平台，并选择 \"App\" 模板。</p>\n</li>\n<li>\n<p>配置项目信息\n下个窗口中为项目配置一些基本信息，如项目名称、组织标识符、语言和用户界面。在这里，选择 SwiftUI 作为用户界面，并将语言设置为 Swift。</p>\n</li>\n<li>\n<p>创建项目\n在配置完项目信息后，单击 \"Next\" 按钮，并选择保存项目的位置。最后，单击 \"Create\" 按钮即可创建新的 SwiftUI 项目。</p>\n</li>\n<li>\n<p>运行项目\n创建新的 SwiftUI 项目后可以在 Xcode 中运行该项目以查看默认的用户界面。单击 \"Run\" 按钮，Xcode 将自动编译并运行。</p>\n</li>\n</ul>","y":"a","t":"02.项目初始化"},["/开发/『SwiftUI』/2.html","/%E5%BC%80%E5%8F%91/%E3%80%8ESwiftUI%E3%80%8F/2","/开发/『SwiftUI』/2.md","/%E5%BC%80%E5%8F%91/%E3%80%8ESwiftUI%E3%80%8F/2.md"]],
  ["v-12c57d0e","/%E5%BC%80%E5%8F%91/%E3%80%8ESwiftUI%E3%80%8F/3.html",{"d":"2022-5-12","l":"2022年5月12日","c":["iOS","Swift","SwiftUI"],"e":"<h1> 03.视图结构</h1>\n<h2> 视图结构</h2>\n<p>在 SwiftUI 中，视图是构建用户界面的基本单元。每个视图都是由其他视图组成的，这种嵌套结构形成了一个视图树。根据应用程序的需要，可以使用各种视图类型来构建视图树，例如文本视图、图像视图、按钮视图等。<br></p>\n<p>在 SwiftUI 中，我们可以使用 View 协议来定义自定义视图。我们可以在自定义视图中定义视图的外观和行为，并将其组合到其他视图中。</p>\n<h2> 组合方式</h2>\n<p>SwiftUI 的一个关键特性是视图的组合方式。在 SwiftUI 中，可以将多个视图组合在一起以创建复杂的用户界面。可以使用诸如 VStack、HStack、ZStack 等容器视图来组合视图。</p>","y":"a","t":"03.视图结构"},["/开发/『SwiftUI』/3.html","/%E5%BC%80%E5%8F%91/%E3%80%8ESwiftUI%E3%80%8F/3","/开发/『SwiftUI』/3.md","/%E5%BC%80%E5%8F%91/%E3%80%8ESwiftUI%E3%80%8F/3.md"]],
  ["v-147a55ad","/%E5%BC%80%E5%8F%91/%E3%80%8ESwiftUI%E3%80%8F/4.html",{"d":"2022-5-24","l":"2022年5月24日","c":["iOS","Swift","SwiftUI"],"e":"<h1> 04.状态管理和数据绑定</h1>\n<p>在 Swift 和 Objective-C 中，我们使用代理和观察者模式来管理状态，但是在 SwiftUI 中，它引入了一种新的方法来管理状态 - 声明式数据流。</p>\n<h2> 状态管理</h2>\n<p>在 SwiftUI 中，状态是希望应用程序在运行时更改的值。例如，可以为颜色、大小、位置等设置状态。在 SwiftUI 中，状态管理非常简单，因为每当状态更改时，视图自动重新渲染。</p>\n<p>使用 @State 属性包装器声明状态，例如：</p>\n<div class=\"language-swift line-numbers-mode\" data-ext=\"swift\"><pre class=\"language-swift\"><code><span class=\"token keyword\">struct</span> <span class=\"token class-name\">ContentView</span><span class=\"token punctuation\">:</span> <span class=\"token class-name\">View</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token attribute atrule\">@State</span> <span class=\"token keyword\">private</span> <span class=\"token keyword\">var</span> isOn <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span>\n    \n    <span class=\"token keyword\">var</span> body<span class=\"token punctuation\">:</span> <span class=\"token keyword\">some</span> <span class=\"token class-name\">View</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token class-name\">Toggle</span><span class=\"token punctuation\">(</span>isOn<span class=\"token punctuation\">:</span> $isOn<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token class-name\">Text</span><span class=\"token punctuation\">(</span><span class=\"token string-literal\"><span class=\"token string\">\"Switch\"</span></span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>","y":"a","t":"04.状态管理和数据绑定"},["/开发/『SwiftUI』/4.html","/%E5%BC%80%E5%8F%91/%E3%80%8ESwiftUI%E3%80%8F/4","/开发/『SwiftUI』/4.md","/%E5%BC%80%E5%8F%91/%E3%80%8ESwiftUI%E3%80%8F/4.md"]],
  ["v-162f2e4c","/%E5%BC%80%E5%8F%91/%E3%80%8ESwiftUI%E3%80%8F/5.html",{"d":"2022-5-26","l":"2022年5月26日","c":["iOS","Swift","SwiftUI"],"e":"<h1> 05.基本视图类型</h1>\n<p>SwiftUI 提供了许多不同的视图类型和功能，使开发者能够快速创建丰富的用户界面。</p>\n<h2> Text</h2>\n<p>Text 视图用于在应用程序中显示文本。可以通过在 Text 视图中传入字符串来设置文本内容，也可以在 Text 视图中使用格式化字符串。</p>\n<div class=\"language-swift line-numbers-mode\" data-ext=\"swift\"><pre class=\"language-swift\"><code><span class=\"token class-name\">Text</span><span class=\"token punctuation\">(</span><span class=\"token string-literal\"><span class=\"token string\">\"Hello, world!\"</span></span><span class=\"token punctuation\">)</span>\n<span class=\"token class-name\">Text</span><span class=\"token punctuation\">(</span><span class=\"token string-literal\"><span class=\"token string\">\"The current count is: </span><span class=\"token interpolation-punctuation punctuation\">\\(</span><span class=\"token interpolation\">count</span><span class=\"token interpolation-punctuation punctuation\">)</span><span class=\"token string\">\"</span></span><span class=\"token punctuation\">)</span>\n</code></pre><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>","y":"a","t":"05.基本视图类型"},["/开发/『SwiftUI』/5.html","/%E5%BC%80%E5%8F%91/%E3%80%8ESwiftUI%E3%80%8F/5","/开发/『SwiftUI』/5.md","/%E5%BC%80%E5%8F%91/%E3%80%8ESwiftUI%E3%80%8F/5.md"]],
  ["v-17e406eb","/%E5%BC%80%E5%8F%91/%E3%80%8ESwiftUI%E3%80%8F/6.html",{"d":"2022-5-29","l":"2022年5月29日","c":["iOS","Swift","SwiftUI"],"e":"<h1> 06.布局</h1>\n<p>在 SwiftUI 中，布局是通过在视图层次结构中嵌套视图来完成的。您可以使用各种视图类型和布局修饰符来控制视图的位置和大小。</p>\n<h2> 布局</h2>\n<p>SwiftUI 提供了许多布局视图类型，例如 HStack、VStack、ZStack 和 Spacer。这些视图类型用于创建水平、垂直和层叠布局。</p>\n<h3> HStack</h3>\n<p>HStack 用于创建水平布局。在 HStack 中添加的视图将按水平方向排列。可以使用 spacing 参数设置每个子视图之间的距离。</p>\n<div class=\"language-swift line-numbers-mode\" data-ext=\"swift\"><pre class=\"language-swift\"><code><span class=\"token class-name\">HStack</span><span class=\"token punctuation\">(</span>alignment<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">.</span>center<span class=\"token punctuation\">,</span> spacing<span class=\"token punctuation\">:</span> <span class=\"token number\">20</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token class-name\">Text</span><span class=\"token punctuation\">(</span><span class=\"token string-literal\"><span class=\"token string\">\"Hello\"</span></span><span class=\"token punctuation\">)</span>\n    <span class=\"token class-name\">Text</span><span class=\"token punctuation\">(</span><span class=\"token string-literal\"><span class=\"token string\">\"World\"</span></span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n</code></pre><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>","y":"a","t":"06.布局"},["/开发/『SwiftUI』/6.html","/%E5%BC%80%E5%8F%91/%E3%80%8ESwiftUI%E3%80%8F/6","/开发/『SwiftUI』/6.md","/%E5%BC%80%E5%8F%91/%E3%80%8ESwiftUI%E3%80%8F/6.md"]],
  ["v-1998df8a","/%E5%BC%80%E5%8F%91/%E3%80%8ESwiftUI%E3%80%8F/7.html",{"d":"2022-6-02","l":"2022年6月2日","c":["iOS","Swift","SwiftUI"],"e":"<h1> 07.自定义视图和容器</h1>\n<p>在 SwiftUI 中，自定义视图和容器是非常常见的。有时候需要将一个视图包裹在自定义的容器中，以便在其他地方使用。</p>\n<h2> 自定义视图</h2>\n<p>可以通过继承 View 来创建自定义视图。下面是一个自定义视图的例子：</p>\n<div class=\"language-swift line-numbers-mode\" data-ext=\"swift\"><pre class=\"language-swift\"><code><span class=\"token keyword\">struct</span> <span class=\"token class-name\">CustomView</span><span class=\"token punctuation\">:</span> <span class=\"token class-name\">View</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> body<span class=\"token punctuation\">:</span> <span class=\"token keyword\">some</span> <span class=\"token class-name\">View</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token class-name\">Text</span><span class=\"token punctuation\">(</span><span class=\"token string-literal\"><span class=\"token string\">\"Hello, World!\"</span></span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>","y":"a","t":"07.自定义视图和容器"},["/开发/『SwiftUI』/7.html","/%E5%BC%80%E5%8F%91/%E3%80%8ESwiftUI%E3%80%8F/7","/开发/『SwiftUI』/7.md","/%E5%BC%80%E5%8F%91/%E3%80%8ESwiftUI%E3%80%8F/7.md"]],
  ["v-1b4db829","/%E5%BC%80%E5%8F%91/%E3%80%8ESwiftUI%E3%80%8F/8.html",{"d":"2022-6-05","l":"2022年6月5日","c":["iOS","Swift","SwiftUI"],"e":"<h1> 08.基本动画类型</h1>\n<p>在 SwiftUI 中，可以使用内置的动画来使应用程序更加生动和有趣。这些动画可以用于各种效果，例如渐变、缩放和旋转。</p>\n<h2> 动画类型</h2>\n<p>在 SwiftUI 中，有四种基本的动画类型：opacity、scale、offset 和 rotation。每种类型都有不同的动画选项，可以自定义动画的速度、时间和效果。</p>\n<h3> Opacity</h3>\n<p>Opacity 动画可以让视图透明度从 0 到 1 或从 1 到 0 的过程中产生渐变效果。</p>\n<div class=\"language-swift line-numbers-mode\" data-ext=\"swift\"><pre class=\"language-swift\"><code><span class=\"token class-name\">Text</span><span class=\"token punctuation\">(</span><span class=\"token string-literal\"><span class=\"token string\">\"Hello, world!\"</span></span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">opacity</span><span class=\"token punctuation\">(</span>isHidden <span class=\"token operator\">?</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">:</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">animation</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">.</span>easeInOut<span class=\"token punctuation\">)</span>\n</code></pre><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>","y":"a","t":"08.基本动画类型"},["/开发/『SwiftUI』/8.html","/%E5%BC%80%E5%8F%91/%E3%80%8ESwiftUI%E3%80%8F/8","/开发/『SwiftUI』/8.md","/%E5%BC%80%E5%8F%91/%E3%80%8ESwiftUI%E3%80%8F/8.md"]],
  ["v-1d0290c8","/%E5%BC%80%E5%8F%91/%E3%80%8ESwiftUI%E3%80%8F/9.html",{"d":"2022-8-07","l":"2022年8月7日","c":["iOS","Swift","SwiftUI"],"g":["UI","动画"],"e":"<h1> 09.过渡动画</h1>\n<p>在 iOS 应用程序中，过渡动画可以为用户提供更好的界面交互体验，使界面切换更加平滑和自然。SwiftUI 中提供了多种内置的过渡动画类型，同时也支持自定义动画。</p>\n<h2> 系统过渡动画</h2>\n<p>SwiftUI 中提供了多种内置的过渡动画类型，可以在视图间进行切换时使用。这些动画类型都是基于系统提供的 Core Animation 框架实现的，因此性能非常高效。下面是一些常用的内置过渡动画类型：</p>\n<ul>\n<li>.default：默认过渡动画，包括淡入淡出和滑动两种效果。</li>\n<li>.scale：缩放过渡动画，视图从小到大或从大到小缩放。</li>\n<li>.slide：滑动过渡动画，视图在屏幕中从左往右或从右往左滑动。</li>\n<li>.opacity：透明度过渡动画，视图从完全透明到不透明或反之。</li>\n<li>.move：移动过渡动画，视图在屏幕中移动。</li>\n<li>.offset：偏移过渡动画，视图在屏幕中沿着 x 轴或 y 轴移动。\n下面是一个简单的示例代码，展示如何使用内置过渡动画：</li>\n</ul>","y":"a","t":"09.过渡动画"},["/开发/『SwiftUI』/9.html","/%E5%BC%80%E5%8F%91/%E3%80%8ESwiftUI%E3%80%8F/9","/开发/『SwiftUI』/9.md","/%E5%BC%80%E5%8F%91/%E3%80%8ESwiftUI%E3%80%8F/9.md"]],
  ["v-730164bc","/%E5%BC%80%E5%8F%91/%E3%80%8ESwift%E3%80%8F/1.html",{"d":"2020-12-21T00:00:00.000Z","l":"2020年12月21日","c":["iOS","Swift"],"g":["语法"],"e":"<h1> 数组、集合、元祖、字典</h1>\n<h2> Array (数组)</h2>\n<p>数组是作为单个值存储的值的集合：</p>\n<div class=\"language-swift line-numbers-mode\" data-ext=\"swift\"><pre class=\"language-swift\"><code><span class=\"token keyword\">let</span> one <span class=\"token operator\">=</span> <span class=\"token string-literal\"><span class=\"token string\">\"panda\"</span></span>\n<span class=\"token keyword\">let</span> two <span class=\"token operator\">=</span> <span class=\"token string-literal\"><span class=\"token string\">\"monkey\"</span></span>\n<span class=\"token keyword\">let</span> three <span class=\"token operator\">=</span> <span class=\"token string-literal\"><span class=\"token string\">\"tiger\"</span></span>\n<span class=\"token keyword\">let</span> four <span class=\"token operator\">=</span> <span class=\"token string-literal\"><span class=\"token string\">\"hippo\"</span></span>\n<span class=\"token keyword\">let</span> all <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>one<span class=\"token punctuation\">,</span> two<span class=\"token punctuation\">,</span> three<span class=\"token punctuation\">,</span> four<span class=\"token punctuation\">]</span>\n</code></pre><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>","y":"a","t":"数组、集合、元祖、字典"},["/开发/『Swift』/1.html","/%E5%BC%80%E5%8F%91/%E3%80%8ESwift%E3%80%8F/1","/开发/『Swift』/1.md","/%E5%BC%80%E5%8F%91/%E3%80%8ESwift%E3%80%8F/1.md"]],
  ["v-254391b4","/%E5%BC%80%E5%8F%91/%E3%80%8ESwift%E3%80%8F/10.html",{"d":"2021-2-06","l":"2021年2月6日","c":["iOS","Swift"],"e":"<h1> SwiftLint 基本用法</h1>\n<p>SwiftLint是Realm强制执行Swift风格和惯例的工具。在Github上拥有超过1万颗星的开发人员所采用。默认情况下，其启用了很多规则。这里讨论一些默认情况下未启用的有价值的规则。</p>\n<h2> convenience</h2>\n<p>通过使用无大小写枚举仅托管静态成员来避免实例化：</p>\n<div class=\"language-swift line-numbers-mode\" data-ext=\"swift\"><pre class=\"language-swift\"><code><span class=\"token keyword\">enum</span> <span class=\"token class-name\">Math</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">// enum</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">let</span> pi <span class=\"token operator\">=</span> <span class=\"token number\">3.14</span>\n<span class=\"token punctuation\">}</span>\n</code></pre><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>","y":"a","t":"SwiftLint 基本用法"},["/开发/『Swift』/10.html","/%E5%BC%80%E5%8F%91/%E3%80%8ESwift%E3%80%8F/10","/开发/『Swift』/10.md","/%E5%BC%80%E5%8F%91/%E3%80%8ESwift%E3%80%8F/10.md"]],
  ["v-21d9e076","/%E5%BC%80%E5%8F%91/%E3%80%8ESwift%E3%80%8F/11.html",{"d":"2021-2-12","l":"2021年2月12日","c":["iOS","Swift"],"g":["语法"],"e":"<h1> required</h1>\n<blockquote>\n<p>required关键字可以在Swift中的初始化器前面使用。</p>\n<p>子类有不同于父类的初始化方法时（参数类型和数量异于父类），子类必须要实现父类的required初始化方法，并且也要使用required修饰符而不是override。</p>\n<p>当子类没有初始化方法时，可以不用实现父类的required初始化方法。</p>\n</blockquote>\n<p>例一：</p>\n<div class=\"language-swift line-numbers-mode\" data-ext=\"swift\"><pre class=\"language-swift\"><code><span class=\"token keyword\">class</span> <span class=\"token class-name\">Person</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">func</span> <span class=\"token function-definition function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token function\">print</span><span class=\"token punctuation\">(</span><span class=\"token string-literal\"><span class=\"token string\">\"running\"</span></span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token comment\">//    required func eat() {//required无法修饰方法，required修饰符只能用于修饰类初始化方法。</span>\n<span class=\"token comment\">//        print(\"eating\")</span>\n<span class=\"token comment\">//    }</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">//继承</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Teacher</span><span class=\"token punctuation\">:</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">override</span> <span class=\"token keyword\">func</span> <span class=\"token function-definition function\">eat</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">super</span><span class=\"token punctuation\">.</span><span class=\"token function\">eat</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">print</span><span class=\"token punctuation\">(</span><span class=\"token string-literal\"><span class=\"token string\">\"eating sth.\"</span></span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>","y":"a","t":"required"},["/开发/『Swift』/11.html","/%E5%BC%80%E5%8F%91/%E3%80%8ESwift%E3%80%8F/11","/开发/『Swift』/11.md","/%E5%BC%80%E5%8F%91/%E3%80%8ESwift%E3%80%8F/11.md"]],
  ["v-1e702f38","/%E5%BC%80%E5%8F%91/%E3%80%8ESwift%E3%80%8F/12.html",{"d":"2021-2-15","l":"2021年2月15日","c":["iOS","Swift"],"g":["区分"],"e":"<h1> weak self、unowned self</h1>\n<p>Swift中weak self and unowned self的很难理解。虽然自动引用计数（ARC）已经为解决了很多问题，但当不处理值类型时，我们仍然需要管理引用。\n在编写闭包等内容时经常会遇到情况，这些情况要求我们细致考虑。</p>\n<h2> ARC、retain、release</h2>\n<p>在ARC之前，我们必须手动管理内存和引用。这引起了许多出错和麻烦，许多开发人员可能会知道。当新实例retain对象时，引用计数会上升，而一旦引用被realease，引用计数就会下降。一旦没有对对象的引用，内存就会被释放，这意味着不再需要该对象。</p>","y":"a","t":"weak self、unowned self"},["/开发/『Swift』/12.html","/%E5%BC%80%E5%8F%91/%E3%80%8ESwift%E3%80%8F/12","/开发/『Swift』/12.md","/%E5%BC%80%E5%8F%91/%E3%80%8ESwift%E3%80%8F/12.md"]],
  ["v-74b63d5b","/%E5%BC%80%E5%8F%91/%E3%80%8ESwift%E3%80%8F/2.html",{"d":"2020-12-23T00:00:00.000Z","l":"2020年12月23日","c":["iOS","Swift"],"g":["语法"],"e":"<h1> 闭包</h1>\n<h2> 创建基本闭包</h2>\n<p>创建了一个没有名称的函数，并将该函数分配给playing：</p>\n<div class=\"language-swift line-numbers-mode\" data-ext=\"swift\"><pre class=\"language-swift\"><code><span class=\"token keyword\">let</span> playing <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">print</span><span class=\"token punctuation\">(</span><span class=\"token string-literal\"><span class=\"token string\">\"I am to play basketball\"</span></span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n</code></pre><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>","y":"a","t":"闭包"},["/开发/『Swift』/2.html","/%E5%BC%80%E5%8F%91/%E3%80%8ESwift%E3%80%8F/2","/开发/『Swift』/2.md","/%E5%BC%80%E5%8F%91/%E3%80%8ESwift%E3%80%8F/2.md"]],
  ["v-766b15fa","/%E5%BC%80%E5%8F%91/%E3%80%8ESwift%E3%80%8F/3.html",{"d":"2020-12-30T00:00:00.000Z","l":"2020年12月30日","c":["iOS","Swift"],"g":["语法"],"e":"<h1> 协议和扩展</h1>\n<h2> 协议 (Protocol)</h2>\n<p>协议是一种描述某物必须具有的属性和方法的方式。告诉Swift哪些类型使用该协议——这个过程被称为采用协议。\n编写一个函数来接受具有id属性的东西，但我们并不关心使用哪种类型的数据。\n首先创建一个Identifiable协议，该协议将要求所有符合要求的类型都有一个可以读取（“get”）或写入（“set”）的id字符串：</p>\n<div class=\"language-swift line-numbers-mode\" data-ext=\"swift\"><pre class=\"language-swift\"><code><span class=\"token keyword\">protocol</span> <span class=\"token class-name\">Identifiable</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> id<span class=\"token punctuation\">:</span> <span class=\"token class-name\">String</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">get</span> <span class=\"token keyword\">set</span> <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>","y":"a","t":"协议和扩展"},["/开发/『Swift』/3.html","/%E5%BC%80%E5%8F%91/%E3%80%8ESwift%E3%80%8F/3","/开发/『Swift』/3.md","/%E5%BC%80%E5%8F%91/%E3%80%8ESwift%E3%80%8F/3.md"]],
  ["v-781fee99","/%E5%BC%80%E5%8F%91/%E3%80%8ESwift%E3%80%8F/4.html",{"d":"2021-1-03","l":"2021年1月3日","c":["iOS","Swift"],"g":["语法"],"e":"<h1> 可选类型</h1>\n<h2> 处理丢失数据</h2>\n<p>使用Int等类型来保整数。但是，如果想为用户存储age属性，如果你不知道某人的年龄，你会怎么做？\n或许可以使用1000或-1等特殊数字来表示“未知”，这两个数字都是不可能的年龄，但真的会记得它使用的所有地方的这个数字吗？\nSwift的解决方案是可选类型，可以制作任何类型的可选类型。可选整数可能有一个像0或40这样的数字，但可能根本没有值——nil。\n要使类型可选，请在它后面添加一个问号：</p>\n<div class=\"language-swift line-numbers-mode\" data-ext=\"swift\"><pre class=\"language-swift\"><code><span class=\"token keyword\">var</span> age<span class=\"token punctuation\">:</span> <span class=\"token class-name\">Int</span><span class=\"token operator\">?</span> <span class=\"token operator\">=</span> <span class=\"token nil constant\">nil</span>\n</code></pre><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div>","y":"a","t":"可选类型"},["/开发/『Swift』/4.html","/%E5%BC%80%E5%8F%91/%E3%80%8ESwift%E3%80%8F/4","/开发/『Swift』/4.md","/%E5%BC%80%E5%8F%91/%E3%80%8ESwift%E3%80%8F/4.md"]],
  ["v-79d4c738","/%E5%BC%80%E5%8F%91/%E3%80%8ESwift%E3%80%8F/5.html",{"d":"2021-1-06","l":"2021年1月6日","c":["iOS","Swift"],"g":["语法","区分"],"e":"<h1> as，as?，as!</h1>\n<p>下面第二行代码具有运行时错误：</p>\n<div class=\"language-swift line-numbers-mode\" data-ext=\"swift\"><pre class=\"language-swift\"><code><span class=\"token number\">8</span> <span class=\"token keyword\">as</span> <span class=\"token class-name\">Double</span> <span class=\"token comment\">// fine</span>\n<span class=\"token number\">8</span> <span class=\"token keyword\">as</span><span class=\"token operator\">!</span> <span class=\"token class-name\">Double</span> <span class=\"token comment\">// crashes</span>\n</code></pre><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>","y":"a","t":"as，as?，as!"},["/开发/『Swift』/5.html","/%E5%BC%80%E5%8F%91/%E3%80%8ESwift%E3%80%8F/5","/开发/『Swift』/5.md","/%E5%BC%80%E5%8F%91/%E3%80%8ESwift%E3%80%8F/5.md"]],
  ["v-7b899fd7","/%E5%BC%80%E5%8F%91/%E3%80%8ESwift%E3%80%8F/6.html",{"d":"2021-1-06","l":"2021年1月6日","c":["iOS","Swift"],"e":"<h1> Equatable</h1>\n<p>检查两个对象或值是否被视为相等，这绝对是所有编程中最常见的操作之一。\nSwift实现相等的一个最有趣的方面是它都是以一种面向协议的方式完成的——任何类型都可以通过遵守Equatable协议而变得等效，协议可以这样做：</p>\n<div class=\"language-swift line-numbers-mode\" data-ext=\"swift\"><pre class=\"language-swift\"><code><span class=\"token keyword\">struct</span> <span class=\"token class-name\">Article</span><span class=\"token punctuation\">:</span> <span class=\"token class-name\">Equatable</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">static</span> <span class=\"token keyword\">func</span> <span class=\"token operator\">==</span><span class=\"token punctuation\">(</span>lhs<span class=\"token punctuation\">:</span> <span class=\"token keyword\">Self</span><span class=\"token punctuation\">,</span> rhs<span class=\"token punctuation\">:</span> <span class=\"token keyword\">Self</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-&gt;</span> <span class=\"token class-name\">Bool</span> <span class=\"token punctuation\">{</span>\n        lhs<span class=\"token punctuation\">.</span>title <span class=\"token operator\">==</span> rhs<span class=\"token punctuation\">.</span>title <span class=\"token operator\">&amp;&amp;</span> lhs<span class=\"token punctuation\">.</span>body <span class=\"token operator\">==</span> rhs<span class=\"token punctuation\">.</span>body\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">var</span> title<span class=\"token punctuation\">:</span> <span class=\"token class-name\">String</span>\n    <span class=\"token keyword\">var</span> body<span class=\"token punctuation\">:</span> <span class=\"token class-name\">String</span>\n<span class=\"token punctuation\">}</span>\n</code></pre><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>","y":"a","t":"Equatable"},["/开发/『Swift』/6.html","/%E5%BC%80%E5%8F%91/%E3%80%8ESwift%E3%80%8F/6","/开发/『Swift』/6.md","/%E5%BC%80%E5%8F%91/%E3%80%8ESwift%E3%80%8F/6.md"]],
  ["v-7d3e7876","/%E5%BC%80%E5%8F%91/%E3%80%8ESwift%E3%80%8F/7.html",{"d":"2021-1-12","l":"2021年1月12日","c":["iOS","Swift"],"e":"<h1> 类型推断</h1>\n<p>Swift是一种静态类型语言，这意味着声明的每个属性、常量和变量的类型都需要在编译时指定。然而，这通常不是需要手动完成的事情，相反，编译器能够自行计算出广泛的类型信息——这要归功于Swift支持类型推断。</p>\n<p>这里声明了一些常量——所有这些都没有指定任何类型，因为编译器能够根据分配的值推断该信息：</p>\n<div class=\"language-swift line-numbers-mode\" data-ext=\"swift\"><pre class=\"language-swift\"><code><span class=\"token keyword\">let</span> number <span class=\"token operator\">=</span> <span class=\"token number\">42</span>\n<span class=\"token keyword\">let</span> string <span class=\"token operator\">=</span> <span class=\"token string-literal\"><span class=\"token string\">\"Hello, world!\"</span></span>\n<span class=\"token keyword\">let</span> array <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">8</span><span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">let</span> dictionary <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token string-literal\"><span class=\"token string\">\"key\"</span></span><span class=\"token punctuation\">:</span> <span class=\"token string-literal\"><span class=\"token string\">\"value\"</span></span><span class=\"token punctuation\">]</span>\n</code></pre><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>","y":"a","t":"类型推断"},["/开发/『Swift』/7.html","/%E5%BC%80%E5%8F%91/%E3%80%8ESwift%E3%80%8F/7","/开发/『Swift』/7.md","/%E5%BC%80%E5%8F%91/%E3%80%8ESwift%E3%80%8F/7.md"]],
  ["v-7ef35115","/%E5%BC%80%E5%8F%91/%E3%80%8ESwift%E3%80%8F/8.html",{"d":"2021-1-17","l":"2021年1月17日","c":["iOS","Swift"],"g":["语法"],"e":"<h1> defer</h1>\n<p>defer关键字在Swift 2.0中引入，但在项目中仍然很少使用。</p>\n<h2> defer语句</h2>\n<p>defer语句用于在将程序控制转移到语句出现的范围之外之前执行代码。</p>\n<div class=\"language-swift line-numbers-mode\" data-ext=\"swift\"><pre class=\"language-swift\"><code><span class=\"token keyword\">func</span> <span class=\"token function-definition function\">updateImage</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">defer</span> <span class=\"token punctuation\">{</span> <span class=\"token function\">print</span><span class=\"token punctuation\">(</span><span class=\"token string-literal\"><span class=\"token string\">\"Did update image\"</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span>\n\n    <span class=\"token function\">print</span><span class=\"token punctuation\">(</span><span class=\"token string-literal\"><span class=\"token string\">\"Will update image\"</span></span><span class=\"token punctuation\">)</span>\n    imageView<span class=\"token punctuation\">.</span>image <span class=\"token operator\">=</span> updatedImage\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// Will update Image</span>\n<span class=\"token comment\">// Did update image</span>\n</code></pre><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>","y":"a","t":"defer"},["/开发/『Swift』/8.html","/%E5%BC%80%E5%8F%91/%E3%80%8ESwift%E3%80%8F/8","/开发/『Swift』/8.md","/%E5%BC%80%E5%8F%91/%E3%80%8ESwift%E3%80%8F/8.md"]],
  ["v-feafac98","/%E5%BC%80%E5%8F%91/%E3%80%8ESwift%E3%80%8F/9.html",{"d":"2021-1-25","l":"2021年1月25日","c":["iOS","Swift"],"g":["语法"],"e":"<h1> where</h1>\n<h2> switch中使用</h2>\n<p>定义枚举：</p>\n<div class=\"language-swift line-numbers-mode\" data-ext=\"swift\"><pre class=\"language-swift\"><code><span class=\"token keyword\">enum</span> <span class=\"token class-name\">Action</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">case</span> <span class=\"token function\">createUser</span><span class=\"token punctuation\">(</span>age<span class=\"token punctuation\">:</span> <span class=\"token class-name\">Int</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">case</span> createPost\n    <span class=\"token keyword\">case</span> logout\n<span class=\"token punctuation\">}</span>\n</code></pre><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>","y":"a","t":"where"},["/开发/『Swift』/9.html","/%E5%BC%80%E5%8F%91/%E3%80%8ESwift%E3%80%8F/9","/开发/『Swift』/9.md","/%E5%BC%80%E5%8F%91/%E3%80%8ESwift%E3%80%8F/9.md"]],
  ["v-17c4c450","/%E5%BC%80%E5%8F%91/%E3%80%8EVue%E3%80%8F/0.html",{"d":"2021-3-05","l":"2021年3月5日","c":["Vue","前端"],"e":"<h1> 一些记录</h1>\n<p>在 Vue.js 应用程序开发中，需要注意一些细节。</p>\n<ul>\n<li>需要在 DOM 元素上进行挂载。</li>\n</ul>\n<blockquote>\n<p>如果在挂载之前，没有将 Vue.js 应用程序实例化，则会导致错误。</p>\n</blockquote>\n<ul>\n<li>提供一个根元素非常重要。</li>\n</ul>\n<blockquote>\n<p>根元素是所有其他元素的父元素，并且是应用程序与 DOM 之间的桥梁。</p>\n</blockquote>\n<ul>\n<li>所有自定义元素都需要在 Vue.js 应用程序实例化之前进行注册。</li>\n</ul>","y":"a","t":"一些记录"},["/开发/『Vue』/0.html","/%E5%BC%80%E5%8F%91/%E3%80%8EVue%E3%80%8F/0","/开发/『Vue』/0.md","/%E5%BC%80%E5%8F%91/%E3%80%8EVue%E3%80%8F/0.md"]],
  ["v-19799cef","/%E5%BC%80%E5%8F%91/%E3%80%8EVue%E3%80%8F/1.html",{"d":"2021-3-07","l":"2021年3月7日","c":["Vue","前端"],"e":"<h1> 简介和基本结构</h1>\n<p>Vue 是一款流行的前端框架，它的出现让前端开发变得更加高效和灵活。<br>\nVue 提供了响应式的数据绑定和组件化的开发方式，使得开发者能够更加专注于业务逻辑的实现，而无需过多关注 DOM 操作和状态管理。</p>\n<h2> 简介</h2>\n<h3> 数据驱动视图</h3>\n<ul>\n<li>高效灵活：Vue 的组件化开发方式让代码更加模块化，提高了代码的复用性和可维护性。</li>\n<li>响应式数据绑定：Vue 的数据绑定采用双向绑定机制，可以让数据的变化自动反映到视图上，极大地简化了代码的书写。</li>\n<li>生态丰富：Vue 的生态系统非常丰富，包括 Vue Router、Vuex 等插件和工具，可以满足不同场景下的需求。</li>\n</ul>","y":"a","t":"简介和基本结构"},["/开发/『Vue』/1.html","/%E5%BC%80%E5%8F%91/%E3%80%8EVue%E3%80%8F/1","/开发/『Vue』/1.md","/%E5%BC%80%E5%8F%91/%E3%80%8EVue%E3%80%8F/1.md"]],
  ["v-1b2e758e","/%E5%BC%80%E5%8F%91/%E3%80%8EVue%E3%80%8F/2.html",{"d":"2021-3-08","l":"2021年3月8日","c":["Vue","前端"],"g":["UI","交互"],"e":"<h1> 事件处理</h1>\n<p>在Vue应用程序中，事件处理是非常重要的一部分。</p>\n<h2> 事件绑定</h2>\n<p>在Vue中可以使用 v-on 指令来绑定事件处理器函数。<br>\n例如可以在一个按钮上绑定一个点击事件处理器：</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><pre class=\"language-html\"><code><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>template</span><span class=\"token punctuation\">&gt;</span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>button</span> <span class=\"token attr-name\"><span class=\"token namespace\">v-on:</span>click</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>handleClick<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">&gt;</span></span>Click Me!<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>button</span><span class=\"token punctuation\">&gt;</span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>template</span><span class=\"token punctuation\">&gt;</span></span>\n\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>script</span><span class=\"token punctuation\">&gt;</span></span><span class=\"token script\"><span class=\"token language-javascript\">\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token literal-property property\">methods</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">handleClick</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Button clicked!'</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>script</span><span class=\"token punctuation\">&gt;</span></span>\n</code></pre><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>","y":"a","t":"事件处理"},["/开发/『Vue』/2.html","/%E5%BC%80%E5%8F%91/%E3%80%8EVue%E3%80%8F/2","/开发/『Vue』/2.md","/%E5%BC%80%E5%8F%91/%E3%80%8EVue%E3%80%8F/2.md"]],
  ["v-1ce34e2d","/%E5%BC%80%E5%8F%91/%E3%80%8EVue%E3%80%8F/3.html",{"d":"2021-3-11","l":"2021年3月11日","c":["Vue","前端"],"g":["语法"],"e":"<h1> 计算属性</h1>\n<p>Vue.js是一款强大的JavaScript框架，提供了许多功能，其中包括计算属性。</p>\n<h2> 什么是计算属性？</h2>\n<p>计算属性是Vue中一种便捷的属性，它能够根据已有的数据计算出新的数据。计算属性可以像普通属性一样在模板中使用，并且具有缓存功能，只有在依赖的数据发生变化时才会重新计算。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><pre class=\"language-javascript\"><code><span class=\"token keyword\">new</span> <span class=\"token class-name\">Vue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  <span class=\"token literal-property property\">data</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token literal-property property\">message</span><span class=\"token operator\">:</span> <span class=\"token string\">'Hello'</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">computed</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 计算属性的 getter</span>\n    <span class=\"token function-variable function\">reversedMessage</span><span class=\"token operator\">:</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// `this` 指向 Vue 实例</span>\n      <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>message<span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">''</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">reverse</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token string\">''</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n</code></pre><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>","y":"a","t":"计算属性"},["/开发/『Vue』/3.html","/%E5%BC%80%E5%8F%91/%E3%80%8EVue%E3%80%8F/3","/开发/『Vue』/3.md","/%E5%BC%80%E5%8F%91/%E3%80%8EVue%E3%80%8F/3.md"]],
  ["v-1e9826cc","/%E5%BC%80%E5%8F%91/%E3%80%8EVue%E3%80%8F/4.html",{"d":"2021-3-18","l":"2021年3月18日","c":["Vue","前端"],"e":"<h1> 插槽</h1>\n<p>插槽是Vue中非常重要的一个特性，它允许我们将组件的内容分发到它的子组件中。通过插槽可以很容易地定义一个可重用的组件，使它在不同的场景下具有不同的表现形式，而不需要改变组件的实现方式。</p>\n<h2> 基本用法</h2>\n<p>插槽是Vue组件中的一种占位符，它可以接受父组件传递的任意内容，并将其分发到插槽所在的子组件中。插槽可以是默认插槽，也可以是具名插槽。</p>\n<h3> 默认插槽</h3>\n<p>默认插槽是Vue组件中未命名的插槽，当父组件没有提供具名插槽时，会将所有内容分发到默认插槽中。默认插槽可以用一个 <code>&lt;slot&gt;</code> 标签表示。</p>","y":"a","t":"插槽"},["/开发/『Vue』/4.html","/%E5%BC%80%E5%8F%91/%E3%80%8EVue%E3%80%8F/4","/开发/『Vue』/4.md","/%E5%BC%80%E5%8F%91/%E3%80%8EVue%E3%80%8F/4.md"]],
  ["v-204cff6b","/%E5%BC%80%E5%8F%91/%E3%80%8EVue%E3%80%8F/5.html",{"d":"2021-3-27","l":"2021年3月27日","c":["Vue","前端"],"g":["生命周期"],"e":"<h1> 生命周期</h1>\n<h2> 钩子函数执行顺序</h2>\n<p>这些函数分为四个阶段：创建阶段、挂载阶段、更新阶段和销毁阶段。</p>\n<h3> 创建阶段</h3>\n<p>在这个阶段，Vue 实例正在初始化。在这个阶段，Vue 实例将设置数据观察和事件、虚拟节点等。</p>\n<ul>\n<li>beforeCreate：在实例化之后，初始化之前执行。</li>\n<li>created：在实例化之后，初始化之后执行。</li>\n</ul>\n<h3> 挂载阶段</h3>\n<p>在这个阶段，Vue 实例正在准备把自己渲染到DOM中。</p>\n<ul>\n<li>beforeMount：在挂载开始之前执行。</li>\n<li>mounted：在挂载结束后执行。</li>\n</ul>","y":"a","t":"生命周期"},["/开发/『Vue』/5.html","/%E5%BC%80%E5%8F%91/%E3%80%8EVue%E3%80%8F/5","/开发/『Vue』/5.md","/%E5%BC%80%E5%8F%91/%E3%80%8EVue%E3%80%8F/5.md"]],
  ["v-2201d80a","/%E5%BC%80%E5%8F%91/%E3%80%8EVue%E3%80%8F/6.html",{"d":"2021-4-02","l":"2021年4月2日","c":["Vue","前端"],"e":"<h1> 指令</h1>\n<p>在 Vue 中，指令是一种特殊的指令，用于为 DOM 元素添加特殊功能。Vue 提供了一些内置指令，例如 v-if、v-for、v-bind 和 v-on，同时也允许开发人员创建自定义指令。</p>\n<h2> 内置指令</h2>\n<p>Vue 提供了一些内置指令，用于实现常见的功能。</p>\n<h3> v-if 和 v-show</h3>\n<p>v-if 指令用于根据条件显示或隐藏元素，它会根据表达式的值来判断元素是否显示。v-show 指令也用于显示或隐藏元素，但是它只是通过 CSS 的 display 属性来控制元素的显示和隐藏，而不是从 DOM 中删除或添加元素。</p>","y":"a","t":"指令"},["/开发/『Vue』/6.html","/%E5%BC%80%E5%8F%91/%E3%80%8EVue%E3%80%8F/6","/开发/『Vue』/6.md","/%E5%BC%80%E5%8F%91/%E3%80%8EVue%E3%80%8F/6.md"]],
  ["v-23b6b0a9","/%E5%BC%80%E5%8F%91/%E3%80%8EVue%E3%80%8F/7.html",{"d":"2021-4-05","l":"2021年4月5日","c":["Vue","前端"],"e":"<h1> 数据共享</h1>\n<p>在 Vue.js 中，组件是一个非常重要的概念，而组件之间的数据共享也是 Vue.js 构建复杂应用的基础。</p>\n<h2> Props</h2>\n<p>使用Props可以让父组件向子组件传递数据。子组件通过Props接收这些数据并在模板中使用。</p>\n<p>父组件：</p>\n<div class=\"language-php line-numbers-mode\" data-ext=\"php\"><pre class=\"language-php\"><code><span class=\"token operator\">&lt;</span>template<span class=\"token operator\">&gt;</span>\n  <span class=\"token operator\">&lt;</span>child<span class=\"token operator\">-</span>component <span class=\"token punctuation\">:</span>message<span class=\"token operator\">=</span><span class=\"token string double-quoted-string\">\"message\"</span> <span class=\"token operator\">/</span><span class=\"token operator\">&gt;</span>\n<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>template<span class=\"token operator\">&gt;</span>\n\n<span class=\"token operator\">&lt;</span>script<span class=\"token operator\">&gt;</span>\nimport ChildComponent from <span class=\"token string double-quoted-string\">\"./ChildComponent.vue\"</span><span class=\"token punctuation\">;</span>\n\nexport <span class=\"token keyword\">default</span> <span class=\"token punctuation\">{</span>\n  components<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    ChildComponent<span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token function\">data</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>\n      message<span class=\"token punctuation\">:</span> <span class=\"token string double-quoted-string\">\"Hello World!\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>script<span class=\"token operator\">&gt;</span>\n</code></pre><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>","y":"a","t":"数据共享"},["/开发/『Vue』/7.html","/%E5%BC%80%E5%8F%91/%E3%80%8EVue%E3%80%8F/7","/开发/『Vue』/7.md","/%E5%BC%80%E5%8F%91/%E3%80%8EVue%E3%80%8F/7.md"]],
  ["v-283ff50e","/%E5%BC%80%E5%8F%91/%E3%80%8EXcode%E3%80%8F/1.html",{"d":"2019-09-24T00:00:00.000Z","l":"2019年9月24日","c":["Xcode","iOS"],"g":["调试"],"e":"<h1> Xcode断点技巧</h1>\n<p>Xcode断点允许调试并找到bug的解决方案。如果没有断点，代码中到处都是打印语句。</p>\n<h2> 什么是断点？</h2>\n<p>可以将断点放置在某行代码上，并在执行期间暂停应用程序，以检查应用程序的状态。可以在应用程序运行之前和期间随时设置断点。\n<br>\n可以在断点导航器中显示所有已激活和禁用的断点。调试栏包含断点激活按钮，以临时禁用断点暂停应用程序。</p>\n<figure><figcaption>Xcode中蓝色断点激活按钮</figcaption></figure>\n<h2> 1：用户定义的断点</h2>\n<p>对于每个新Xcode项目，可能要做的少数事情之一是添加那些帮助调试许多bug的方便断点。这个冗余的过程可以通过Xcode中用户定义的断点来解决。\n\n移动断点后，它将显示在包含所有用户定义断点的自身部分中。\n\n这使得断点在打开的每个Xcode项目中都可用。这包括创建的项目以及从互联网下载的项目。</p>","y":"a","t":"Xcode断点技巧"},["/开发/『Xcode』/1.html","/%E5%BC%80%E5%8F%91/%E3%80%8EXcode%E3%80%8F/1","/开发/『Xcode』/1.md","/%E5%BC%80%E5%8F%91/%E3%80%8EXcode%E3%80%8F/1.md"]],
  ["v-29f4cdad","/%E5%BC%80%E5%8F%91/%E3%80%8EXcode%E3%80%8F/2.html",{"d":"2020-11-15T00:00:00.000Z","l":"2020年11月15日","c":["Xcode","iOS"],"g":["优化"],"e":"<h1> Xcode bulid速度</h1>\n<p>在Xcode中分析build性能，以加快Xcode build速度。这可以轻松加快工作流程并节省大量时间。</p>\n<h2> Build With Timing Summary</h2>\n<p>Xcode 10引入了带有 Build with Timing summary 功能。build一次项目并生成每个类别所花费的时间概览。\n<br></p>\n<blockquote>\n<p>功能入口:</p>\n<p>Product ➔ Perform Action ➔ Build with Timing Summary或使用xcodebuild -showBuildTimingSummary</p>\n</blockquote>","y":"a","t":"Xcode bulid速度"},["/开发/『Xcode』/2.html","/%E5%BC%80%E5%8F%91/%E3%80%8EXcode%E3%80%8F/2","/开发/『Xcode』/2.md","/%E5%BC%80%E5%8F%91/%E3%80%8EXcode%E3%80%8F/2.md"]],
  ["v-2ba9a64c","/%E5%BC%80%E5%8F%91/%E3%80%8EXcode%E3%80%8F/3.html",{"d":"2018-11-03T00:00:00.000Z","l":"2018年11月3日","c":["Xcode","iOS"],"g":["调试"],"e":"<h1> Xcode快捷操作</h1>\n<h2> 基本快捷键</h2>\n<p>Build：\t⌘B <br>\nRun：\t⌘R <br>\nTest：⌘U <br>\nStop：⌘. <br>\nClean：⇧⌘K <br>\n切换导航栏：⌘(1-9) <br>\n前进页：⌃⌘→ <br>\n回退页：⌃⌘← <br>\n文件中查找：⌘F <br>\n项目中查找：⇧⌘F <br>\n显示完成：⌃Space <br></p>\n<h2> run without building</h2>\n<p>^ ctrl + ⌘ command + R</p>\n<h2> 显示document items</h2>\n<p>Show Document Items：\t^6\nGoto line：\t⌘L</p>","y":"a","t":"Xcode快捷操作"},["/开发/『Xcode』/3.html","/%E5%BC%80%E5%8F%91/%E3%80%8EXcode%E3%80%8F/3","/开发/『Xcode』/3.md","/%E5%BC%80%E5%8F%91/%E3%80%8EXcode%E3%80%8F/3.md"]],
  ["v-2d5e7eeb","/%E5%BC%80%E5%8F%91/%E3%80%8EXcode%E3%80%8F/4.html",{"d":"2021-01-06T00:00:00.000Z","l":"2021年1月6日","c":["Xcode","iOS"],"e":"<h1> Xcode launch screens</h1>\n<p>当程序跑起来，Launch screens出现，加载应用程序后，用户可以开始使用应用程序。<br>\nXcode默认提供storyboard可以使用它来设置加载屏幕。<br>\n虽然大多数情况下效果很好，但Xcode 12和iOS 14中提供了新选项。</p>\n<h2> launch screens 的历史</h2>\n<p>在Xcode 6之前，我们唯一的选择是在asset目录中提供静态图像。这已经比以前更好了，因为我们曾经为这些图像设置了特定的文件名。<br></p>\n<p>Xcode 6附带的iOS 8允许我们用storyboard替换静态图像。这已经简化并改进了定义加载屏幕的方式，但选项仍然有限。launch screens 被大量缓存，动态替换是不可能的。然而，使用label, imageView和其他界面元素消除了打开图像编辑应用程序以导出所有正确尺寸的图像的要求。<br></p>","y":"a","t":"Xcode launch screens"},["/开发/『Xcode』/4.html","/%E5%BC%80%E5%8F%91/%E3%80%8EXcode%E3%80%8F/4","/开发/『Xcode』/4.md","/%E5%BC%80%E5%8F%91/%E3%80%8EXcode%E3%80%8F/4.md"]],
  ["v-2f13578a","/%E5%BC%80%E5%8F%91/%E3%80%8EXcode%E3%80%8F/5.html",{"d":"2020-10-12T00:00:00.000Z","l":"2020年10月12日","c":["Xcode","iOS"],"g":["调试"],"e":"<h1> LLDB 调试</h1>\n<h2> 原生 LLDB 命令</h2>\n<h3> p</h3>\n<p>打印基本数据类型的值，查看对象返回对象的指针地址。</p>\n<h4> po</h4>\n<p>打印对象的描述，常量、变量、表达式返回的对象等。</p>\n<h4> pclass</h4>\n<p>打印对象继承关系</p>\n<h4> presponder</h4>\n<p>打印响应链</p>\n<h3> bt</h3>\n<p>打印线程的堆栈信息（bt all 打印全部线程堆栈信息）。</p>\n<h3> e</h3>\n<p>动态变量赋值：<br>\nif 处断点，控制台输入 e dataArray.count = 0 回车，继续运行即可：</p>","y":"a","t":"LLDB 调试"},["/开发/『Xcode』/5.html","/%E5%BC%80%E5%8F%91/%E3%80%8EXcode%E3%80%8F/5","/开发/『Xcode』/5.md","/%E5%BC%80%E5%8F%91/%E3%80%8EXcode%E3%80%8F/5.md"]],
  ["v-30c83029","/%E5%BC%80%E5%8F%91/%E3%80%8EXcode%E3%80%8F/6.html",{"d":"2022-04-01T00:00:00.000Z","l":"2022年4月1日","c":["Xcode","iOS"],"e":"<h1> Xcode 清理</h1>\n<p>整理需要或可以清理的相关模块</p>\n<h2> 运行程序产生的缓存文件</h2>\n<p>重新运行Xcode就会重新生成，随着运行程序的增多占用空间会越来越大。</p>\n<ul>\n<li>Cmd + Shift + K&nbsp;或&nbsp;shift + cmd + alt + k&nbsp;进行清理，然后退出Xcode。</li>\n<li>删除缓存：rm -rf ~/Library/Developer/Xcode/DerivedData&nbsp;在终端中运行</li>\n</ul>\n<h2> 历史版本ipa</h2>\n<p>路径：~/Library/Developer/Xcode/Archives</p>","y":"a","t":"Xcode 清理"},["/开发/『Xcode』/6.html","/%E5%BC%80%E5%8F%91/%E3%80%8EXcode%E3%80%8F/6","/开发/『Xcode』/6.md","/%E5%BC%80%E5%8F%91/%E3%80%8EXcode%E3%80%8F/6.md"]],
  ["v-f8f49cd4","/%E5%BC%80%E5%8F%91/%E3%80%8EiOS%E3%80%8F/1.html",{"d":"2020-5-02","l":"2020年5月2日","c":["iOS"],"g":["UI","交互"],"e":"<h1> 事件传递机制</h1>\n<p>iOS中用户的操作会被转换为UI事件，并由系统传递给应用程序。这个过程涉及到多个对象的交互，其中包括UIApplication、UIWindow、UIView和UIResponder。</p>\n<h2> 事件的传递过程</h2>\n<p>当用户在屏幕上进行操作时，如点击按钮或滑动屏幕，这些操作将被转换为UI事件。这些事件将从UIApplication对象开始传递，经过UIWindow和UIView，最终到达事件的目标响应对象。<br></p>\n<p>事件传递机制是一个基于响应链的过程。当用户执行某个操作时（例如点击屏幕），系统会将该操作转换为一个或多个 UI 事件，并将其传递给应用程序。<br></p>","y":"a","t":"事件传递机制"},["/开发/『iOS』/1.html","/%E5%BC%80%E5%8F%91/%E3%80%8EiOS%E3%80%8F/1","/开发/『iOS』/1.md","/%E5%BC%80%E5%8F%91/%E3%80%8EiOS%E3%80%8F/1.md"]],
  ["v-2538f4e8","/%E5%BC%80%E5%8F%91/%E3%80%8EiOS%E3%80%8F/10.html",{"d":"2019-2-12","l":"2019年2月12日","c":["iOS"],"g":["多线程"],"e":"<h1> 锁</h1>\n<p>在iOS中，我们有多种不同类型的锁可用于线程同步。在选择使用哪种锁时，需要考虑到线程数量、性能需求、锁的等待时间和锁的粒度等因素。<br>\n在选择使用哪种锁时，需要考虑到线程数量、性能需求、锁的等待时间和锁的粒度等因素。下面我们对每种锁进行比较分析。</p>\n<h2> 互斥锁</h2>\n<p>互斥锁是最基本的锁，也是最常用的锁之一。它可以保证在同一时间只有一个线程访问共享资源，因此是一种安全可靠的锁机制。但是，使用互斥锁时需要注意锁的粒度，如果锁的粒度过细，会导致线程频繁地抢占锁资源，从而降低程序的性能。在 iOS 中，可以使用 NSLock 和 pthread_mutex_t</p>","y":"a","t":"锁"},["/开发/『iOS』/10.html","/%E5%BC%80%E5%8F%91/%E3%80%8EiOS%E3%80%8F/10","/开发/『iOS』/10.md","/%E5%BC%80%E5%8F%91/%E3%80%8EiOS%E3%80%8F/10.md"]],
  ["v-21cf43aa","/%E5%BC%80%E5%8F%91/%E3%80%8EiOS%E3%80%8F/11.html",{"d":"2019-12-22T00:00:00.000Z","l":"2019年12月22日","c":["iOS"],"g":["Block","底层原理"],"e":"<h1> Block循环引用</h1>\n<p>在Objective-C中，Block是一种类似于匿名函数的语法结构，它可以用来封装一段代码，并在需要时执行该代码。尽管Block提供了便利的语法结构，但是在实际使用中，我们经常会遇到一个问题，即Block循环引用。</p>\n<p>Block循环引用是指在Block内部捕获了一个对象，并且该对象又持有了该Block，从而导致两者互相持有，无法释放内存。这个问题不仅会导致内存泄漏，还会影响程序的性能和稳定性。</p>\n<h2> Block的本质</h2>\n<p>在深入探讨Block循环引用之前需要了解一下Block的本质。在Objective-C中，Block实际上是一种OC对象，它是由以下三个部分组成的：</p>","y":"a","t":"Block循环引用"},["/开发/『iOS』/11.html","/%E5%BC%80%E5%8F%91/%E3%80%8EiOS%E3%80%8F/11","/开发/『iOS』/11.md","/%E5%BC%80%E5%8F%91/%E3%80%8EiOS%E3%80%8F/11.md"]],
  ["v-1e65926c","/%E5%BC%80%E5%8F%91/%E3%80%8EiOS%E3%80%8F/12.html",{"d":"2020-7-02","l":"2020年7月2日","c":["iOS"],"g":["代码之外"],"e":"<h1> 静态库与动态库</h1>\n<p>在iOS开发中，库是一个非常常见的概念，它是一组预编译的二进制代码，可以被应用程序调用，以便重复使用和提高代码的可维护性。iOS中的库主要分为两种：静态库和动态库。</p>\n<h2> 静态库</h2>\n<p>静态库是一组已经编译好的二进制代码，它们被打包成一个单独的文件，可以在编译时链接到应用程序中。静态库的扩展名通常为.a。在链接时，编译器会将静态库的代码复制到可执行文件中，因此它们可以被静态链接到应用程序中，这意味着应用程序在运行时不需要依赖任何外部库或动态链接器。<br></p>\n<p>静态库的优点在于它们非常容易使用，因为它们包含所有必需的代码和符号，这样就可以保证应用程序在不同的环境中具有相同的行为。此外，静态库的代码在链接时就已经被编译和优化了，因此它们在应用程序中的性能通常比动态库更好。最后，静态库在应用程序中的安全性也更高，因为它们不能被动态修改或替换。<br></p>","y":"a","t":"静态库与动态库"},["/开发/『iOS』/12.html","/%E5%BC%80%E5%8F%91/%E3%80%8EiOS%E3%80%8F/12","/开发/『iOS』/12.md","/%E5%BC%80%E5%8F%91/%E3%80%8EiOS%E3%80%8F/12.md"]],
  ["v-1afbe12e","/%E5%BC%80%E5%8F%91/%E3%80%8EiOS%E3%80%8F/13.html",{"d":"2018-9-12","l":"2018年9月12日","c":["iOS"],"g":["框架"],"e":"<h1> SDWebImage框架分析</h1>\n<p>SDWebImage是iOS开发中常用的异步图片加载框架，它提供了许多方便的功能，如异步下载图片、图片缓存、图片解压缩、图片处理等。</p>\n<h2> 主要功能</h2>\n<p>SDWebImage主要有以下几个功能和优势：</p>\n<ul>\n<li>异步下载图片：使用NSURLConnection或NSURLSession实现图片的异步下载，避免了在主线程中下载图片导致的UI卡顿和性能下降。</li>\n<li>图片缓存：使用NSCache和磁盘缓存实现图片的缓存，避免了重复下载图片和提高了图片加载速度。</li>\n<li>图片解压缩：使用libjpeg-turbo和libwebp等库对图片进行解压缩，提高了图片的显示效果和性能。</li>\n<li>图片处理：支持图片的裁剪、缩放、圆角、渐进式加载等处理，提供了更丰富的图片展示效果。</li>\n</ul>","y":"a","t":"SDWebImage框架分析"},["/开发/『iOS』/13.html","/%E5%BC%80%E5%8F%91/%E3%80%8EiOS%E3%80%8F/13","/开发/『iOS』/13.md","/%E5%BC%80%E5%8F%91/%E3%80%8EiOS%E3%80%8F/13.md"]],
  ["v-17922ff0","/%E5%BC%80%E5%8F%91/%E3%80%8EiOS%E3%80%8F/14.html",{"d":"2018-5-12","l":"2018年5月12日","c":["iOS"],"g":["底层原理","UI"],"e":"<h1> CoreGraphics 和 CoraAnimation</h1>\n<p>iOS开发中常常需要用到图形绘制和动画效果。其中，Core Graphics和Core Animation是两个非常重要的框架。它们分别提供了图形绘制和动画效果的功能。Core Graphics与Core Animation两个框架有不同的作用和优势。</p>\n<h2> Core Graphics</h2>\n<p>Core Graphics是一组C语言API，提供了一系列的绘图功能，可以创建并绘制各种类型的图形，例如线条、矩形、多边形、渐变、图片等等。Core Graphics主要是针对图形的绘制和处理，提供了一套完整的绘图模型，支持复杂的图形组合和变换。<br></p>","y":"a","t":"CoreGraphics 和 CoraAnimation"},["/开发/『iOS』/14.html","/%E5%BC%80%E5%8F%91/%E3%80%8EiOS%E3%80%8F/14","/开发/『iOS』/14.md","/%E5%BC%80%E5%8F%91/%E3%80%8EiOS%E3%80%8F/14.md"]],
  ["v-14287eb2","/%E5%BC%80%E5%8F%91/%E3%80%8EiOS%E3%80%8F/15.html",{"d":"2019-6-06","l":"2019年6月6日","c":["iOS"],"g":["UI"],"e":"<h1> 关于CALayer</h1>\n<p>CALayer 是一个 Core Animation 框架下的一个类，它是 UIView 中负责显示内容的部分。CALayer 有着强大的绘图能力，可以显示图片、文本等内容。相比于 UIView，CALayer 的优势在于它能够处理更加底层的绘图操作，并且能够实现更好的性能优化。</p>\n<h2> 什么是 CALayer</h2>\n<p>CALayer 是 Core Animation 框架下的一个类，它是 UIView 中负责显示内容的部分。CALayer 能够处理更加底层的绘图操作，包括绘制图片、文本等内容。CALayer 可以独立于视图而存在，也可以和视图一起使用。<br></p>","y":"a","t":"关于CALayer"},["/开发/『iOS』/15.html","/%E5%BC%80%E5%8F%91/%E3%80%8EiOS%E3%80%8F/15","/开发/『iOS』/15.md","/%E5%BC%80%E5%8F%91/%E3%80%8EiOS%E3%80%8F/15.md"]],
  ["v-10becd74","/%E5%BC%80%E5%8F%91/%E3%80%8EiOS%E3%80%8F/16.html",{"d":"2020-1-19","l":"2020年1月19日","c":["iOS"],"g":["UI"],"e":"<h1> 三个方法区分</h1>\n<p>initWithCode、awakaFromNib、initWithNibName 这三个方法都是用于创建 UIViewController 的初始化方法：</p>\n<h2> initWithCoder:</h2>\n<p>这是一个 NSCoding 协议中定义的方法，用于从归档数据中解码并初始化对象。在使用 Interface Builder 设计 UI 界面时，会将 UIViewController 对象编码为归档数据，并在运行时进行解码初始化。因此，当我们使用 Interface Builder 设计 UI 界面时，通常会使用这个方法来初始化 UIViewController 对象。</p>","y":"a","t":"三个方法区分"},["/开发/『iOS』/16.html","/%E5%BC%80%E5%8F%91/%E3%80%8EiOS%E3%80%8F/16","/开发/『iOS』/16.md","/%E5%BC%80%E5%8F%91/%E3%80%8EiOS%E3%80%8F/16.md"]],
  ["v-0d551c36","/%E5%BC%80%E5%8F%91/%E3%80%8EiOS%E3%80%8F/17.html",{"d":"2020-5-09","l":"2020年5月9日","c":["iOS"],"g":["Block"],"e":"<h1> Block种类</h1>\n<p>在 Objective-C 中，Block 是一种带有自动捕获变量的匿名函数。Block 可以在定义时捕获其外部作用域中的变量，并将这些变量保存在 Block 结构体中。当调用 Block 时，它会从结构体中获取这些变量，并执行函数体中的代码。Block 的定义形式如下：</p>\n<div class=\"language-objective line-numbers-mode\" data-ext=\"objective\"><pre class=\"language-objective\"><code>^return_type (arguments) {\n    // code\n}\n</code></pre><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>","y":"a","t":"Block种类"},["/开发/『iOS』/17.html","/%E5%BC%80%E5%8F%91/%E3%80%8EiOS%E3%80%8F/17","/开发/『iOS』/17.md","/%E5%BC%80%E5%8F%91/%E3%80%8EiOS%E3%80%8F/17.md"]],
  ["v-09eb6af8","/%E5%BC%80%E5%8F%91/%E3%80%8EiOS%E3%80%8F/18.html",{"d":"2019-7-23","l":"2019年7月23日","c":["iOS"],"g":["UI"],"e":"<h1> UIView的layout方法</h1>\n<h2> layoutSubviews</h2>\n<p>layoutSubviews 方法是 UIView 的一个布局方法，主要用于对 UIView 的子视图进行布局。当 UIView 的 frame 或 bounds 属性发生变化时就会自动调用 layoutSubviews 方法。layoutSubviews 方法默认为空实现，因此我们可以在子类中覆盖这个方法，实现自己的布局逻辑。</p>\n<h3> 调用时机</h3>\n<p>在 iOS 中，UIView 的布局是自下而上的，也就是说，当一个视图的 frame 或 bounds 属性发生变化时，它的所有子视图都会相应地调整布局。在这个过程中，iOS 会先调用父视图的 layoutSubviews 方法，然后再调用子视图的 layoutSubviews 方法。这意味着，如果我们需要修改某个子视图的布局，就可以在父视图的 layoutSubviews 方法中对它进行修改。<br></p>","y":"a","t":"UIView的layout方法"},["/开发/『iOS』/18.html","/%E5%BC%80%E5%8F%91/%E3%80%8EiOS%E3%80%8F/18","/开发/『iOS』/18.md","/%E5%BC%80%E5%8F%91/%E3%80%8EiOS%E3%80%8F/18.md"]],
  ["v-0681b9ba","/%E5%BC%80%E5%8F%91/%E3%80%8EiOS%E3%80%8F/19.html",{"d":"2018-11-29T00:00:00.000Z","l":"2018年11月29日","c":["iOS"],"g":["代码之外"],"e":"<h1> 深入理解iOS沙盒机制</h1>\n<p>iOS沙盒机制是指操作系统将每个应用程序的文件系统隔离开来，从而实现应用程序之间的数据隔离和保护。这个机制为用户数据安全提供了强有力的保障，同时也为应用程序开发者提供了方便的文件系统管理方式。</p>\n<h2> 工作原理</h2>\n<p>沙盒机制是通过为每个应用程序创建独立的文件系统环境来实现的。iOS操作系统将每个应用程序的文件系统放在一个独立的目录下，称为应用程序沙盒。在这个沙盒中，应用程序只能访问自己的文件，而不能访问其他应用程序的文件。这个沙盒中的文件包括应用程序的数据文件、配置文件、临时文件、缓存文件等。</p>\n<h2> 优点</h2>","y":"a","t":"深入理解iOS沙盒机制"},["/开发/『iOS』/19.html","/%E5%BC%80%E5%8F%91/%E3%80%8EiOS%E3%80%8F/19","/开发/『iOS』/19.md","/%E5%BC%80%E5%8F%91/%E3%80%8EiOS%E3%80%8F/19.md"]],
  ["v-f58aeb96","/%E5%BC%80%E5%8F%91/%E3%80%8EiOS%E3%80%8F/2.html",{"d":"2021-6-02","l":"2021年6月2日","c":["iOS"],"g":["UI","优化"],"e":"<h1> UI显示、绘制和卡顿分析</h1>\n<h2> UI显示原理</h2>\n<p>现代计算机系统中，CPU和GPU是两个最重要的硬件组件。CPU（中央处理器）主要负责处理计算机的控制和数据操作，而GPU（图形处理器）则专门负责处理图像和图形相关的计算。<br></p>\n<p>CPU 和 GPU 扮演着不同的角色，各自负责不同的任务。CPU 负责图像数据的加载、解码和处理、以及用户交互事件的处理；GPU 负责图像纹理的渲染、图形渲染流程的执行、以及动画效果的处理。它们之间协同工作，共同完成图像的渲染和显示。<br></p>\n<p>在移动设备中，CPU和GPU的协作是实现UI显示的关键。在CPU中操作UI时，例如创建一个控件、设置一个文本颜色等，这些操作都会最终被转换为一个位图的形式，再通过总线传递给GPU进行渲染和显示。<br></p>","y":"a","t":"UI显示、绘制和卡顿分析"},["/开发/『iOS』/2.html","/%E5%BC%80%E5%8F%91/%E3%80%8EiOS%E3%80%8F/2","/开发/『iOS』/2.md","/%E5%BC%80%E5%8F%91/%E3%80%8EiOS%E3%80%8F/2.md"]],
  ["v-2249c0cd","/%E5%BC%80%E5%8F%91/%E3%80%8EiOS%E3%80%8F/20.html",{"d":"2022-5-19","l":"2022年5月19日","c":["iOS"],"g":["底层原理","代码之外"],"e":"<h1> Mach-O文件简要分析</h1>\n<p>Mach-O文件是一种可执行文件格式，是macOS和iOS系统的重要文件格式之一。</p>\n<h2> 结构</h2>\n<p>Mach-O文件包含三个主要部分：头部、数据部分和加载命令。</p>\n<ul>\n<li>Mach-O 头（Mach Header）：这里描述了 Mach-O 的 CPU 架构、文件类型以及加载命令等信息；</li>\n<li>数据区（Data）：Data 中每一个段（Segment）的数据都保存在此，段的概念和 ELF 文件中段的概念类似，都拥有一个或多个 Section ，用来存放数据和代码。</li>\n<li>加载命令（Load Command）：描述了文件中数据的具体组织结构，不同的数据类型使用不同的加载命令表示；</li>\n</ul>","y":"a","t":"Mach-O文件简要分析"},["/开发/『iOS』/20.html","/%E5%BC%80%E5%8F%91/%E3%80%8EiOS%E3%80%8F/20","/开发/『iOS』/20.md","/%E5%BC%80%E5%8F%91/%E3%80%8EiOS%E3%80%8F/20.md"]],
  ["v-23fe996c","/%E5%BC%80%E5%8F%91/%E3%80%8EiOS%E3%80%8F/21.html",{"d":"2020-5-21","l":"2020年5月21日","c":["iOS"],"g":["runtime"],"e":"<h1> metaclass</h1>\n<p>在Objective-C中，每个类都有一个与之对应的元类。元类中存储了类方法和类属性等信息。当我们使用一个类方法时，实际上是通过类对象（Class object）在元类中查找相应的方法，然后进行调用。<br></p>\n<h2> 作用</h2>\n<ul>\n<li>元类是类的描述类：元类可以描述类的属性和行为，包括类的实例变量、属性、方法等。通过元类，我们可以对类进行更加深入的理解和掌握。</li>\n<li>元类可以创建类对象和类的实例：在Objective-C中，我们可以使用Class关键字创建一个类对象，而类对象又可以用来创建实例对象。这些操作都是通过元类实现的。</li>\n<li>元类支持动态方法解析：元类提供了一个名为resolveClassMethod:或resolveInstanceMethod:的方法，它可以在运行时动态添加类方法或实例方法。这种机制可以帮助我们实现一些非常灵活的程序设计。</li>\n<li>元类支持消息转发机制：在Objective-C中，如果一个对象无法响应某个消息，就会进入消息转发机制。元类也可以参与消息转发机制，用来处理某些特殊情况下的消息转发。</li>\n</ul>","y":"a","t":"metaclass"},["/开发/『iOS』/21.html","/%E5%BC%80%E5%8F%91/%E3%80%8EiOS%E3%80%8F/21","/开发/『iOS』/21.md","/%E5%BC%80%E5%8F%91/%E3%80%8EiOS%E3%80%8F/21.md"]],
  ["v-25b3720b","/%E5%BC%80%E5%8F%91/%E3%80%8EiOS%E3%80%8F/22.html",{"d":"2018-11-17T00:00:00.000Z","l":"2018年11月17日","c":["iOS"],"g":["生命周期"],"e":"<h1> UIViewController 生命周期</h1>\n<ul>\n<li>\n<p>init\nUIViewController 对象被创建，并进行一些基本的初始化操作。开发者可以在这个阶段对 UIViewController 进行一些基本的设置和初始化，但是应该避免访问界面相关的属性和方法，因为这些属性和方法尚未被加载。</p>\n</li>\n<li>\n<p>loadView\nUIViewController 的 view 被创建。开发者可以通过重写 loadView 方法来自定义 view 的创建过程。如果没有重写 loadView 方法，则默认会创建一个空的 UIView 对象，并将其作为 view 属性赋值给 UIViewController。</p>\n</li>\n<li>\n<p>viewDidLoad\nUIViewController 的 view 已经被创建，但还没有被添加到视图层次结构中。开发者可以在这个阶段进行一些初始化工作，如设置界面元素的属性等。在这个阶段，view 的大小已经被确定，但是子视图还没有被创建。</p>\n</li>\n<li>\n<p>viewWillAppear\nUIViewController 的 view 即将被添加到视图层次结构中。在这个阶段，开发者可以对将要显示的界面进行最后的准备工作，如设置界面元素的位置和动画等。</p>\n</li>\n<li>\n<p>viewDidAppear\nUIViewController 的 view 已经完全显示在屏幕上。在这个阶段，开发者可以执行一些界面相关的操作，如加载网络数据或者启动定时器等。</p>\n</li>\n<li>\n<p>viewWillDisappear 和 viewDidDisappear\nUIViewController 的 view 即将被移除或已经被移除。在这个阶段，开发者可以执行一些资源释放的操作，如取消网络请求或停止定时器等。</p>\n</li>\n</ul>","y":"a","t":"UIViewController 生命周期"},["/开发/『iOS』/22.html","/%E5%BC%80%E5%8F%91/%E3%80%8EiOS%E3%80%8F/22","/开发/『iOS』/22.md","/%E5%BC%80%E5%8F%91/%E3%80%8EiOS%E3%80%8F/22.md"]],
  ["v-27684aaa","/%E5%BC%80%E5%8F%91/%E3%80%8EiOS%E3%80%8F/23.html",{"d":"2018-8-07","l":"2018年8月7日","c":["iOS"],"g":["区分"],"e":"<h1> isMemberOfClass 、 isKindOfClass和 isSubclassOfClass</h1>\n<p>isMemberOfClass, isKindOfClass, 和 isSubclassOfClass 是 Objective-C 和 Swift 中用于检查对象类型的方法。<br></p>\n<p>这三个方法都是用来判断一个对象的类型，即判断一个对象是否是某个类或其子类的实例。</p>\n<ul>\n<li>isMemberOfClass 用于检查对象是否是指定类的实例，不包括子类。如果该对象是指定类的实例，则返回 YES，否则返回 NO。</li>\n<li>isKindOfClass 用于检查对象是否是指定类或其子类的实例。如果该对象是指定类或其子类的实例，则返回 YES，否则返回 NO。</li>\n<li>isSubclassOfClass 用于检查一个类是否是另一个类的子类。如果该类是另一个类的子类，则返回 YES，否则返回 NO。</li>\n</ul>","y":"a","t":"isMemberOfClass 、 isKindOfClass和 isSubclassOfClass"},["/开发/『iOS』/23.html","/%E5%BC%80%E5%8F%91/%E3%80%8EiOS%E3%80%8F/23","/开发/『iOS』/23.md","/%E5%BC%80%E5%8F%91/%E3%80%8EiOS%E3%80%8F/23.md"]],
  ["v-291d2349","/%E5%BC%80%E5%8F%91/%E3%80%8EiOS%E3%80%8F/24.html",{"d":"2019-2-06","l":"2019年2月6日","c":["iOS"],"g":["优化","循环引用"],"e":"<h1> 常见循环引用</h1>\n<h2> block</h2>\n<p>self将block作为自己的属性变量，而在block的方法体里面又引用了 self 本身，此时就很简单的形成了一个循环引用。</p>\n<div class=\"language-objective line-numbers-mode\" data-ext=\"objective\"><pre class=\"language-objective\"><code>__weak typeof(self) weakSelf = self;\n__strong typeof (weakSelf) strongSelf = weakSelf;\n</code></pre><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>","y":"a","t":"常见循环引用"},["/开发/『iOS』/24.html","/%E5%BC%80%E5%8F%91/%E3%80%8EiOS%E3%80%8F/24","/开发/『iOS』/24.md","/%E5%BC%80%E5%8F%91/%E3%80%8EiOS%E3%80%8F/24.md"]],
  ["v-2ad1fbe8","/%E5%BC%80%E5%8F%91/%E3%80%8EiOS%E3%80%8F/25.html",{"d":"2021-04-10T00:00:00.000Z","l":"2021年4月10日","c":["iOS"],"g":["区分"],"e":"<h1> isEqual,isEqualToString,==</h1>\n<ul>\n<li>\n<p>isEqual\n默认情况下是比较两个对象的内存地址；isEqual：就是提供了一个可以自定义相等标准的方法。\n系统自带的类(比如 Foundation 中 的 NSString, NSArray 等)重写了这个方法，改变了这个方法的判断规则，一般改为比较两个对象的内容，不是内存地址.</p>\n</li>\n<li>\n<p>isEqualToString\n字符串比较，只比较字符串本身的内容是否一致，不比较内存地址.</p>\n</li>\n<li>\n<p>==\n两个对象的内存地址是一样，返回true，如果内存地址不一样，返回false.</p>\n</li>\n</ul>","y":"a","t":"isEqual,isEqualToString,=="},["/开发/『iOS』/25.html","/%E5%BC%80%E5%8F%91/%E3%80%8EiOS%E3%80%8F/25","/开发/『iOS』/25.md","/%E5%BC%80%E5%8F%91/%E3%80%8EiOS%E3%80%8F/25.md"]],
  ["v-2c86d487","/%E5%BC%80%E5%8F%91/%E3%80%8EiOS%E3%80%8F/26.html",{"d":"2020-7-12","l":"2020年7月12日","c":["iOS"],"g":["区分"],"e":"<h1> alloc 与 init</h1>\n<p>Objective-C 中，alloc 和 init 方法经常一起使用来创建对象<br></p>\n<ul>\n<li>alloc 方法会分配内存空间来存储对象，返回指向该内存空间的指针。这个空间中的值是未定义的，需要使用 init 方法来初始化对象的状态。</li>\n<li>init 方法则是用来初始化对象的状态。它会在对象的内存空间被分配之后立即被调用。通过设置实例变量的初始值、分配和设置默认的资源以及执行其他必要的初始化操作，它可以确保新对象的状态是一致的并且可用的。</li>\n</ul>\n<p>需要注意的是，alloc 方法只是用来分配内存空间，它并不会初始化对象的状态，因此在使用 alloc 方法创建对象时，必须使用 init 方法来初始化该对象。</p>","y":"a","t":"alloc 与 init"},["/开发/『iOS』/26.html","/%E5%BC%80%E5%8F%91/%E3%80%8EiOS%E3%80%8F/26","/开发/『iOS』/26.md","/%E5%BC%80%E5%8F%91/%E3%80%8EiOS%E3%80%8F/26.md"]],
  ["v-2e3bad26","/%E5%BC%80%E5%8F%91/%E3%80%8EiOS%E3%80%8F/27.html",{"d":"2022-8-18","l":"2022年8月18日","c":["iOS"],"g":["代码之外","网络"],"e":"<h1> HTTPS加密原理</h1>\n<p>HTTPS（Hyper Text Transfer Protocol over Secure Socket Layer）是在HTTP的基础上加入了SSL/TLS协议来实现数据加密和身份认证的安全网络协议。HTTPS协议在iOS开发中被广泛应用。在移动应用中，保护用户的隐私和安全至关重要。其中，HTTPS是一种用于保护网络通信安全的加密协议。在iOS中，使用HTTPS来保护应用的网络通信是非常重要的。</p>\n<h2> HTTPS加密原理</h2>\n<p>HTTPS协议主要通过SSL/TLS协议实现加密通信和身份认证。SSL（Secure Sockets Layer）是一个基于非对称密钥加密和对称密钥加密结合的协议，TLS（Transport Layer Security）则是SSL的升级版，是目前互联网上使用最广泛的安全协议。<br></p>","y":"a","t":"HTTPS加密原理"},["/开发/『iOS』/27.html","/%E5%BC%80%E5%8F%91/%E3%80%8EiOS%E3%80%8F/27","/开发/『iOS』/27.md","/%E5%BC%80%E5%8F%91/%E3%80%8EiOS%E3%80%8F/27.md"]],
  ["v-2ff085c5","/%E5%BC%80%E5%8F%91/%E3%80%8EiOS%E3%80%8F/28.html",{"d":"2022-10-11T00:00:00.000Z","l":"2022年10月11日","c":["iOS"],"g":["区分","底层原理"],"e":"<h1> SEL和Method和IM</h1>\n<p>SEL是方法名称，Method包含方法名称、参数类型和返回类型等信息，IMP是实际执行方法代码的函数指针。</p>\n<h2> SEL（选择器）</h2>\n<p>用于表示一个方法的名称。每个方法都有一个唯一的SEL，它是在运行时动态创建的。当使用对象发送消息时，实际上是通过SEL来调用方法。<br></p>\n<p>例如，如果有一个方法叫做doSomething，那么它对应的SEL就是@selector(doSomething)。在发送消息时，可以使用这个SEL来调用doSomething方法：</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><pre class=\"language-text\"><code>SEL funcSelector = @selector(func);\n[obj performSelector:funcSelector];\n</code></pre><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>","y":"a","t":"SEL和Method和IM"},["/开发/『iOS』/28.html","/%E5%BC%80%E5%8F%91/%E3%80%8EiOS%E3%80%8F/28","/开发/『iOS』/28.md","/%E5%BC%80%E5%8F%91/%E3%80%8EiOS%E3%80%8F/28.md"]],
  ["v-31a55e64","/%E5%BC%80%E5%8F%91/%E3%80%8EiOS%E3%80%8F/29.html",{"d":"2023-3-10","l":"2023年3月10日","c":["iOS","swift"],"g":["区分","底层原理"],"e":"<h1> Swift 与 OC</h1>\n<h2> 共同点</h2>\n<ul>\n<li>都是C语言的超集。OC在C语言基础上添加了一些面向对象编程的特性，Swift也是建立在C语言基础之上。</li>\n<li>OC的引用计数、ARC、属性、协议、接口、初始化、扩展类、命名参数、匿名函数等，在Swift中继续有效。</li>\n<li>Swift和OC共用一套运行时环境，Swift的类型可以桥接到OC，反之亦然</li>\n</ul>\n<h2> swift 优点</h2>\n<h3> 更安全</h3>\n<p>swift更安全，OC更灵活 <br></p>\n<p>swift 安全性，包括：</p>\n<ul>\n<li>类型安全：Swift 是一种静态类型语言，编译时会检查变量类型，可以避免一些常见的类型错误，如类型转换错误、访问不存在的方法或属性等。<br></li>\n<li>内存安全：Swift 使用自动引用计数 (ARC) 来管理内存，可以避免常见的内存泄漏和野指针问题。<br></li>\n<li>安全的字符串和集合操作：Swift 提供了强类型的字符串和集合类型，可以避免常见的字符串和集合操作中的缓冲区溢出和数组越界等安全问题。<br></li>\n</ul>","y":"a","t":"Swift 与 OC"},["/开发/『iOS』/29.html","/%E5%BC%80%E5%8F%91/%E3%80%8EiOS%E3%80%8F/29","/开发/『iOS』/29.md","/%E5%BC%80%E5%8F%91/%E3%80%8EiOS%E3%80%8F/29.md"]],
  ["v-f2213a58","/%E5%BC%80%E5%8F%91/%E3%80%8EiOS%E3%80%8F/3.html",{"d":"2020-9-03","l":"2020年9月3日","c":["iOS"],"g":["UI","优化"],"e":"<h1> UI离屏渲染</h1>\n<p>UI离屏渲染是指将需要绘制的图层从当前屏幕分离出来，进行单独的处理，然后再将处理结果合并到当前屏幕上。在iOS中，离屏渲染会带来额外的系统开销，可能会降低性能，因此需要谨慎使用。</p>\n<h2> 出现原因</h2>\n<p>当一个图层需要在屏幕上呈现时，系统会将该图层的内容绘制到一张位图上，然后再将该位图绘制到屏幕上。如果这个图层有一些需要额外处理的属性，比如圆角、阴影、透明度等，那么系统就需要在绘制位图之前，先对这些属性进行处理，处理完之后再将位图绘制到屏幕上，这就是离屏渲染。<br></p>\n<h2> 常见操作</h2>\n<p>常见的离屏渲染操作</p>","y":"a","t":"UI离屏渲染"},["/开发/『iOS』/3.html","/%E5%BC%80%E5%8F%91/%E3%80%8EiOS%E3%80%8F/3","/开发/『iOS』/3.md","/%E5%BC%80%E5%8F%91/%E3%80%8EiOS%E3%80%8F/3.md"]],
  ["v-eeb7891a","/%E5%BC%80%E5%8F%91/%E3%80%8EiOS%E3%80%8F/4.html",{"d":"2021-12-03T00:00:00.000Z","l":"2021年12月3日","c":["iOS"],"g":["内存管理"],"e":"<h1> iOS系统下的内存布局</h1>\n<p>内存布局是指操作系统在进程运行时为其分配内存空间的方式。iOS系统是一款非常流行的移动操作系统，它的内存布局方式对于iOS开发者来说是非常重要的，因为它直接关系到应用程序的性能和稳定性。</p>\n<h3> 内存分配</h3>\n<p>在iOS系统中，进程的内存空间被划分为几个区域，包括代码段、数据段、堆、栈和BSS段。</p>\n<ul>\n<li>代码段：存储应用程序的可执行代码。</li>\n<li>数据段：存储全局变量和静态变量。</li>\n<li>堆：存储动态分配的内存，包括通过malloc()和new等函数动态分配的内存。</li>\n<li>栈：存储函数的参数、局部变量和函数调用的上下文信息。</li>\n<li>BSS段：存储未初始化的全局变量和静态变量。\n这些区域在进程创建时就被分配好了，而且它们的地址也是固定的。这些区域的大小和位置是由链接器和加载器决定的，而不是应用程序决定的。</li>\n</ul>","y":"a","t":"iOS系统下的内存布局"},["/开发/『iOS』/4.html","/%E5%BC%80%E5%8F%91/%E3%80%8EiOS%E3%80%8F/4","/开发/『iOS』/4.md","/%E5%BC%80%E5%8F%91/%E3%80%8EiOS%E3%80%8F/4.md"]],
  ["v-eb4dd7dc","/%E5%BC%80%E5%8F%91/%E3%80%8EiOS%E3%80%8F/5.html",{"d":"2020-9-08","l":"2020年9月8日","c":["iOS"],"g":["内存管理"],"e":"<h1> 内存管理</h1>\n<p>在iOS操作系统中，针对不同场景下的内存管理，苹果采用了不同的内存管理方案。对于小对象，如NSNumber等，苹果采用了TaggedPoint这种内存管理方案。对于64位架构下的iOS系统，苹果采用了非指针型的ISA来提高内存利用率。而对于复杂对象，苹果采用了散列表来管理内存。这些内存管理方案都是针对不同的场景做出的优化，旨在提高内存的利用率和性能。</p>\n<h2> TaggedPointer</h2>\n<p>TaggedPointer 是一种内存管理方案，适用于一些小对象，如NSNumber等。在 iOS 系统中，每个对象都有一个指向其类信息的指针，通常称为ISA指针。在 64 位架构下，ISA 指针占用了 64 个比特位，但是在实际应用中，只需要使用其中的 32 位或 40 位，剩余的比特位实际上是浪费的。TaggedPointer 就是利用这些浪费的比特位来存储对象的数据，从而提高内存利用率。<br></p>","y":"a","t":"内存管理"},["/开发/『iOS』/5.html","/%E5%BC%80%E5%8F%91/%E3%80%8EiOS%E3%80%8F/5","/开发/『iOS』/5.md","/%E5%BC%80%E5%8F%91/%E3%80%8EiOS%E3%80%8F/5.md"]],
  ["v-e7e4269e","/%E5%BC%80%E5%8F%91/%E3%80%8EiOS%E3%80%8F/6.html",{"d":"2019-9-12","l":"2019年9月12日","c":["iOS"],"g":["runtime","底层原理"],"e":"<h1> 消息传递机制</h1>\n<p>在 iOS 应用开发中，消息传递是一种常见的通信方式。消息传递机制可以让不同对象之间进行通信，以实现程序的协调和交互。消息传递是一种基于 Objective-C 运行时的机制。Objective-C 运行时是一种运行时库，它允许程序在运行时进行动态类型检查、方法调用、消息传递等操作。Objective-C 运行时是 iOS 开发中的核心之一，它允许开发者在运行时动态创建和修改类、对象和方法等。<br></p>\n<p>消息传递机制的核心是消息发送和消息接收。在 Objective-C 中，消息发送是通过调用对象的方法来完成的。当对象接收到消息后，它会根据消息所携带的信息来调用相应的方法。</p>","y":"a","t":"消息传递机制"},["/开发/『iOS』/6.html","/%E5%BC%80%E5%8F%91/%E3%80%8EiOS%E3%80%8F/6","/开发/『iOS』/6.md","/%E5%BC%80%E5%8F%91/%E3%80%8EiOS%E3%80%8F/6.md"]],
  ["v-e47a7560","/%E5%BC%80%E5%8F%91/%E3%80%8EiOS%E3%80%8F/7.html",{"d":"2019-10-12T00:00:00.000Z","l":"2019年10月12日","c":["iOS"],"g":["底层原理"],"e":"<h1> 关于RunLoop</h1>\n<p>RunLoop 是 iOS 和 macOS 中非常重要的概念之一，它是一个事件循环机制，能够管理事件和计时器，也可以用于处理输入源和输出源。 <br></p>\n<p>RunLoop 是一个事件循环机制，用于在应用程序中处理事件和计时器。RunLoop 为应用程序提供了一种机制，以等待输入源和输出源，同时避免 CPU 的空转。<br>\nRunLoop 是一种基于消息循环的机制。当一个事件发生时，RunLoop 将该事件添加到消息队列中，然后开始处理该消息队列中的事件。这个过程会一直持续下去，直到没有事件需要处理为止。</p>\n<h2> 实现机制</h2>","y":"a","t":"关于RunLoop"},["/开发/『iOS』/7.html","/%E5%BC%80%E5%8F%91/%E3%80%8EiOS%E3%80%8F/7","/开发/『iOS』/7.md","/%E5%BC%80%E5%8F%91/%E3%80%8EiOS%E3%80%8F/7.md"]],
  ["v-e110c422","/%E5%BC%80%E5%8F%91/%E3%80%8EiOS%E3%80%8F/8.html",{"d":"2018-12-12T00:00:00.000Z","l":"2018年12月12日","c":["iOS"],"g":["多线程"],"e":"<h1> 实现常驻线程</h1>\n<p>在 iOS 开发中，我们经常需要实现一个常驻线程来执行一些特定的任务，比如音视频播放、网络请求等，这些任务需要在一个单独的线程中执行，避免阻塞主线程和其他子线程的运行。<br>\n常驻线程指的是一个长期存在的线程，与普通线程不同的是，它不会随着任务的结束而被销毁，而是一直存在于内存中，等待新的任务到来。<br></p>\n<h2> 常驻线程实现</h2>\n<p>实现一个常驻线程的关键在于创建一个与线程关联的 runloop，并在其中添加需要执行的任务。具体实现可以分为以下三个步骤：</p>\n<p>1.创建一个线程对应的 RunLoop\n2.向这个 RunLoop 中添加 Source/Timer/Observer 以及 Port 等内容\n3.调用 CFRunLoop 的 run 方法</p>","y":"a","t":"实现常驻线程"},["/开发/『iOS』/8.html","/%E5%BC%80%E5%8F%91/%E3%80%8EiOS%E3%80%8F/8","/开发/『iOS』/8.md","/%E5%BC%80%E5%8F%91/%E3%80%8EiOS%E3%80%8F/8.md"]],
  ["v-dda712e4","/%E5%BC%80%E5%8F%91/%E3%80%8EiOS%E3%80%8F/9.html",{"d":"2020-10-17T00:00:00.000Z","l":"2020年10月17日","c":["iOS"],"g":["多线程"],"e":"<h1> 用 GCD 实现多读单写</h1>\n<p>在并发编程中，多读单写（Multiple Readers, Single Writer，缩写为MRSW）是一个常见的场景，也是一个经典的问题。在这种情况下，允许多个线程同时读取某个共享资源，但是只允许一个线程进行写入。多读单写是一种常见的优化技术，可以显著提高并发程序的性能和吞吐量。</p>\n<h2> 多读单写问题</h2>\n<p>多读单写问题是一种典型的共享资源问题。在多线程环境下，多个线程同时访问共享资源可能会导致不一致的结果。在MRSW问题中，多个线程可以同时读取共享资源，但是只允许一个线程进行写入。在这种情况下，需要确保在写入期间没有线程正在读取或写入该资源。 <br></p>","y":"a","t":"用 GCD 实现多读单写"},["/开发/『iOS』/9.html","/%E5%BC%80%E5%8F%91/%E3%80%8EiOS%E3%80%8F/9","/开发/『iOS』/9.md","/%E5%BC%80%E5%8F%91/%E3%80%8EiOS%E3%80%8F/9.md"]],
  ["v-3706649a","/404.html",{"y":"p","t":""},["/404"]],
  ["v-9f40f29a","/%E9%9A%8F%E8%AE%B0/",{"y":"p","t":"随记"},["/随记/","/%E9%9A%8F%E8%AE%B0/index.html"]],
  ["v-8a7c859e","/%E5%BC%80%E5%8F%91/%E3%80%8EOther%E3%80%8F/",{"y":"p","t":"『 Other』"},["/开发/『Other』/","/%E5%BC%80%E5%8F%91/%E3%80%8EOther%E3%80%8F/index.html"]],
  ["v-4791d343","/%E5%BC%80%E5%8F%91/",{"y":"p","t":"开发"},["/开发/","/%E5%BC%80%E5%8F%91/index.html"]],
  ["v-551dcaf0","/%E5%BC%80%E5%8F%91/%E3%80%8ESwiftUI%E3%80%8F/",{"y":"p","t":"『 Swift U I』"},["/开发/『SwiftUI』/","/%E5%BC%80%E5%8F%91/%E3%80%8ESwiftUI%E3%80%8F/index.html"]],
  ["v-30725718","/%E5%BC%80%E5%8F%91/%E3%80%8ESwift%E3%80%8F/",{"y":"p","t":"『 Swift』"},["/开发/『Swift』/","/%E5%BC%80%E5%8F%91/%E3%80%8ESwift%E3%80%8F/index.html"]],
  ["v-7a0deee7","/%E5%BC%80%E5%8F%91/%E3%80%8EVue%E3%80%8F/",{"y":"p","t":"『 Vue』"},["/开发/『Vue』/","/%E5%BC%80%E5%8F%91/%E3%80%8EVue%E3%80%8F/index.html"]],
  ["v-5bf6eb74","/%E5%BC%80%E5%8F%91/%E3%80%8EXcode%E3%80%8F/",{"y":"p","t":"『 Xcode』"},["/开发/『Xcode』/","/%E5%BC%80%E5%8F%91/%E3%80%8EXcode%E3%80%8F/index.html"]],
  ["v-dd576664","/%E5%BC%80%E5%8F%91/%E3%80%8EiOS%E3%80%8F/",{"y":"p","t":"『i O S』"},["/开发/『iOS』/","/%E5%BC%80%E5%8F%91/%E3%80%8EiOS%E3%80%8F/index.html"]],
  ["v-5bc93818","/category/",{"y":"p","t":"分类","I":0},["/category/index.html"]],
  ["v-744d024e","/tag/",{"y":"p","t":"标签","I":0},["/tag/index.html"]],
  ["v-e52c881c","/article/",{"y":"p","t":"文章","I":0},["/article/index.html"]],
  ["v-154dc4c4","/star/",{"y":"p","t":"收藏","I":0},["/star/index.html"]],
  ["v-01560935","/timeline/",{"y":"p","t":"时间轴","I":0},["/timeline/index.html"]],
  ["v-65f0d5da","/category/ios/",{"y":"p","t":"iOS 分类","I":0},["/category/ios/index.html"]],
  ["v-0da0f70d","/tag/ui/",{"y":"p","t":"UI 标签","I":0},["/tag/ui/index.html"]],
  ["v-82df6ad8","/category/swift/",{"y":"p","t":"Swift 分类","I":0},["/category/swift/index.html"]],
  ["v-925ee04a","/tag/%E4%BA%A4%E4%BA%92/",{"y":"p","t":"交互 标签","I":0},["/tag/交互/","/tag/%E4%BA%A4%E4%BA%92/index.html"]],
  ["v-5ba90940","/category/swiftui/",{"y":"p","t":"SwiftUI 分类","I":0},["/category/swiftui/index.html"]],
  ["v-2639cad6","/tag/%E8%AF%AD%E6%B3%95/",{"y":"p","t":"语法 标签","I":0},["/tag/语法/","/tag/%E8%AF%AD%E6%B3%95/index.html"]],
  ["v-65f6d381","/category/vue/",{"y":"p","t":"Vue 分类","I":0},["/category/vue/index.html"]],
  ["v-ec4438a6","/tag/%E7%BD%91%E7%BB%9C/",{"y":"p","t":"网络 标签","I":0},["/tag/网络/","/tag/%E7%BD%91%E7%BB%9C/index.html"]],
  ["v-e9c7e408","/category/%E5%89%8D%E7%AB%AF/",{"y":"p","t":"前端 分类","I":0},["/category/前端/","/category/%E5%89%8D%E7%AB%AF/index.html"]],
  ["v-000bed88","/tag/%E5%8A%A8%E7%94%BB/",{"y":"p","t":"动画 标签","I":0},["/tag/动画/","/tag/%E5%8A%A8%E7%94%BB/index.html"]],
  ["v-73fd3efc","/category/xcode/",{"y":"p","t":"Xcode 分类","I":0},["/category/xcode/index.html"]],
  ["v-36447397","/tag/%E5%8C%BA%E5%88%86/",{"y":"p","t":"区分 标签","I":0},["/tag/区分/","/tag/%E5%8C%BA%E5%88%86/index.html"]],
  ["v-727fc466","/tag/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/",{"y":"p","t":"生命周期 标签","I":0},["/tag/生命周期/","/tag/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/index.html"]],
  ["v-849f1c12","/tag/%E8%B0%83%E8%AF%95/",{"y":"p","t":"调试 标签","I":0},["/tag/调试/","/tag/%E8%B0%83%E8%AF%95/index.html"]],
  ["v-3102ad68","/tag/%E4%BC%98%E5%8C%96/",{"y":"p","t":"优化 标签","I":0},["/tag/优化/","/tag/%E4%BC%98%E5%8C%96/index.html"]],
  ["v-415e2fc5","/tag/%E5%A4%9A%E7%BA%BF%E7%A8%8B/",{"y":"p","t":"多线程 标签","I":0},["/tag/多线程/","/tag/%E5%A4%9A%E7%BA%BF%E7%A8%8B/index.html"]],
  ["v-42eb45e0","/tag/block/",{"y":"p","t":"Block 标签","I":0},["/tag/block/index.html"]],
  ["v-2902adac","/tag/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/",{"y":"p","t":"底层原理 标签","I":0},["/tag/底层原理/","/tag/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/index.html"]],
  ["v-13d496ae","/tag/%E4%BB%A3%E7%A0%81%E4%B9%8B%E5%A4%96/",{"y":"p","t":"代码之外 标签","I":0},["/tag/代码之外/","/tag/%E4%BB%A3%E7%A0%81%E4%B9%8B%E5%A4%96/index.html"]],
  ["v-f4d3cd72","/tag/%E6%A1%86%E6%9E%B6/",{"y":"p","t":"框架 标签","I":0},["/tag/框架/","/tag/%E6%A1%86%E6%9E%B6/index.html"]],
  ["v-826600b6","/tag/runtime/",{"y":"p","t":"runtime 标签","I":0},["/tag/runtime/index.html"]],
  ["v-5ecb5bc1","/tag/%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/",{"y":"p","t":"循环引用 标签","I":0},["/tag/循环引用/","/tag/%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/index.html"]],
  ["v-1190a5ee","/tag/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/",{"y":"p","t":"内存管理 标签","I":0},["/tag/内存管理/","/tag/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/index.html"]],
]
