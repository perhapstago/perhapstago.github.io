export const data = JSON.parse("{\"key\":\"v-1e702f38\",\"path\":\"/%E5%BC%80%E5%8F%91/%E3%80%8ESwift%E3%80%8F/12.html\",\"title\":\"weak self、unowned self\",\"lang\":\"zh-CN\",\"frontmatter\":{\"date\":\"2021-2-15\",\"description\":\"weak self、unowned self Swift中weak self and unowned self的很难理解。虽然自动引用计数（ARC）已经为解决了很多问题，但当不处理值类型时，我们仍然需要管理引用。 在编写闭包等内容时经常会遇到情况，这些情况要求我们细致考虑。 ARC、retain、release 在ARC之前，我们必须手动管理内存和引用。这引起了许多出错和麻烦，许多开发人员可能会知道。当新实例retain对象时，引用计数会上升，而一旦引用被realease，引用计数就会下降。一旦没有对对象的引用，内存就会被释放，这意味着不再需要该对象。\",\"head\":[[\"meta\",{\"property\":\"og:url\",\"content\":\"http://yunpu.tech/%E5%BC%80%E5%8F%91/%E3%80%8ESwift%E3%80%8F/12.html\"}],[\"meta\",{\"property\":\"og:site_name\",\"content\":\"夏日的瓜牛\"}],[\"meta\",{\"property\":\"og:title\",\"content\":\"weak self、unowned self\"}],[\"meta\",{\"property\":\"og:description\",\"content\":\"weak self、unowned self Swift中weak self and unowned self的很难理解。虽然自动引用计数（ARC）已经为解决了很多问题，但当不处理值类型时，我们仍然需要管理引用。 在编写闭包等内容时经常会遇到情况，这些情况要求我们细致考虑。 ARC、retain、release 在ARC之前，我们必须手动管理内存和引用。这引起了许多出错和麻烦，许多开发人员可能会知道。当新实例retain对象时，引用计数会上升，而一旦引用被realease，引用计数就会下降。一旦没有对对象的引用，内存就会被释放，这意味着不再需要该对象。\"}],[\"meta\",{\"property\":\"og:type\",\"content\":\"article\"}],[\"meta\",{\"property\":\"og:locale\",\"content\":\"zh-CN\"}],[\"meta\",{\"property\":\"article:published_time\",\"content\":\"2021-02-14T16:00:00.000Z\"}],[\"script\",{\"type\":\"application/ld+json\"},\"{\\\"@context\\\":\\\"https://schema.org\\\",\\\"@type\\\":\\\"Article\\\",\\\"headline\\\":\\\"weak self、unowned self\\\",\\\"image\\\":[\\\"\\\"],\\\"datePublished\\\":\\\"2021-02-14T16:00:00.000Z\\\",\\\"dateModified\\\":null,\\\"author\\\":[]}\"]]},\"headers\":[{\"level\":2,\"title\":\"ARC、retain、release\",\"slug\":\"arc、retain、release\",\"link\":\"#arc、retain、release\",\"children\":[]},{\"level\":2,\"title\":\"何时使用 weak self\",\"slug\":\"何时使用-weak-self\",\"link\":\"#何时使用-weak-self\",\"children\":[]},{\"level\":2,\"title\":\"弱引用、循环引用\",\"slug\":\"弱引用、循环引用\",\"link\":\"#弱引用、循环引用\",\"children\":[]},{\"level\":2,\"title\":\"何时使用 unowned self\",\"slug\":\"何时使用-unowned-self\",\"link\":\"#何时使用-unowned-self\",\"children\":[]},{\"level\":2,\"title\":\"为什么不需要结构体这样的值类型？\",\"slug\":\"为什么不需要结构体这样的值类型\",\"link\":\"#为什么不需要结构体这样的值类型\",\"children\":[]},{\"level\":2,\"title\":\"weak和unowned只与inside closures一起使用吗？\",\"slug\":\"weak和unowned只与inside-closures一起使用吗\",\"link\":\"#weak和unowned只与inside-closures一起使用吗\",\"children\":[]}],\"readingTime\":{\"minutes\":6.25,\"words\":1876},\"filePathRelative\":\"开发/『Swift』/12.md\",\"localizedDate\":\"2021年2月15日\",\"excerpt\":\"<h1> weak self、unowned self</h1>\\n<p>Swift中weak self and unowned self的很难理解。虽然自动引用计数（ARC）已经为解决了很多问题，但当不处理值类型时，我们仍然需要管理引用。\\n在编写闭包等内容时经常会遇到情况，这些情况要求我们细致考虑。</p>\\n<h2> ARC、retain、release</h2>\\n<p>在ARC之前，我们必须手动管理内存和引用。这引起了许多出错和麻烦，许多开发人员可能会知道。当新实例retain对象时，引用计数会上升，而一旦引用被realease，引用计数就会下降。一旦没有对对象的引用，内存就会被释放，这意味着不再需要该对象。</p>\",\"autoDesc\":true}")

if (import.meta.webpackHot) {
  import.meta.webpackHot.accept()
  if (__VUE_HMR_RUNTIME__.updatePageData) {
    __VUE_HMR_RUNTIME__.updatePageData(data)
  }
}

if (import.meta.hot) {
  import.meta.hot.accept(({ data }) => {
    __VUE_HMR_RUNTIME__.updatePageData(data)
  })
}
