export const data = JSON.parse("{\"key\":\"v-2538f4e8\",\"path\":\"/%E5%BC%80%E5%8F%91/%E3%80%8EiOS%E3%80%8F/10.html\",\"title\":\"锁\",\"lang\":\"zh-CN\",\"frontmatter\":{\"date\":\"2019-2-12\",\"category\":[\"iOS\"],\"tag\":[\"多线程\"],\"description\":\"锁 在iOS中，我们有多种不同类型的锁可用于线程同步。在选择使用哪种锁时，需要考虑到线程数量、性能需求、锁的等待时间和锁的粒度等因素。 在选择使用哪种锁时，需要考虑到线程数量、性能需求、锁的等待时间和锁的粒度等因素。下面我们对每种锁进行比较分析。 互斥锁 互斥锁是最基本的锁，也是最常用的锁之一。它可以保证在同一时间只有一个线程访问共享资源，因此是一种安全可靠的锁机制。但是，使用互斥锁时需要注意锁的粒度，如果锁的粒度过细，会导致线程频繁地抢占锁资源，从而降低程序的性能。在 iOS 中，可以使用 NSLock 和 pthread_mutex_t\",\"head\":[[\"meta\",{\"property\":\"og:url\",\"content\":\"http://yunpu.tech/%E5%BC%80%E5%8F%91/%E3%80%8EiOS%E3%80%8F/10.html\"}],[\"meta\",{\"property\":\"og:site_name\",\"content\":\"夏日的瓜牛\"}],[\"meta\",{\"property\":\"og:title\",\"content\":\"锁\"}],[\"meta\",{\"property\":\"og:description\",\"content\":\"锁 在iOS中，我们有多种不同类型的锁可用于线程同步。在选择使用哪种锁时，需要考虑到线程数量、性能需求、锁的等待时间和锁的粒度等因素。 在选择使用哪种锁时，需要考虑到线程数量、性能需求、锁的等待时间和锁的粒度等因素。下面我们对每种锁进行比较分析。 互斥锁 互斥锁是最基本的锁，也是最常用的锁之一。它可以保证在同一时间只有一个线程访问共享资源，因此是一种安全可靠的锁机制。但是，使用互斥锁时需要注意锁的粒度，如果锁的粒度过细，会导致线程频繁地抢占锁资源，从而降低程序的性能。在 iOS 中，可以使用 NSLock 和 pthread_mutex_t\"}],[\"meta\",{\"property\":\"og:type\",\"content\":\"article\"}],[\"meta\",{\"property\":\"og:locale\",\"content\":\"zh-CN\"}],[\"meta\",{\"property\":\"article:tag\",\"content\":\"多线程\"}],[\"meta\",{\"property\":\"article:published_time\",\"content\":\"2019-02-11T16:00:00.000Z\"}],[\"script\",{\"type\":\"application/ld+json\"},\"{\\\"@context\\\":\\\"https://schema.org\\\",\\\"@type\\\":\\\"Article\\\",\\\"headline\\\":\\\"锁\\\",\\\"image\\\":[\\\"\\\"],\\\"datePublished\\\":\\\"2019-02-11T16:00:00.000Z\\\",\\\"dateModified\\\":null,\\\"author\\\":[]}\"]]},\"headers\":[{\"level\":2,\"title\":\"互斥锁\",\"slug\":\"互斥锁\",\"link\":\"#互斥锁\",\"children\":[]},{\"level\":2,\"title\":\"自旋锁\",\"slug\":\"自旋锁\",\"link\":\"#自旋锁\",\"children\":[]},{\"level\":2,\"title\":\"信号量\",\"slug\":\"信号量\",\"link\":\"#信号量\",\"children\":[]},{\"level\":2,\"title\":\"读写锁\",\"slug\":\"读写锁\",\"link\":\"#读写锁\",\"children\":[]},{\"level\":2,\"title\":\"递归锁\",\"slug\":\"递归锁\",\"link\":\"#递归锁\",\"children\":[]},{\"level\":2,\"title\":\"原子操作\",\"slug\":\"原子操作\",\"link\":\"#原子操作\",\"children\":[]},{\"level\":2,\"title\":\"选择适当的锁机制\",\"slug\":\"选择适当的锁机制\",\"link\":\"#选择适当的锁机制\",\"children\":[]}],\"readingTime\":{\"minutes\":6.25,\"words\":1874},\"filePathRelative\":\"开发/『iOS』/10.md\",\"localizedDate\":\"2019年2月12日\",\"excerpt\":\"<h1> 锁</h1>\\n<p>在iOS中，我们有多种不同类型的锁可用于线程同步。在选择使用哪种锁时，需要考虑到线程数量、性能需求、锁的等待时间和锁的粒度等因素。<br>\\n在选择使用哪种锁时，需要考虑到线程数量、性能需求、锁的等待时间和锁的粒度等因素。下面我们对每种锁进行比较分析。</p>\\n<h2> 互斥锁</h2>\\n<p>互斥锁是最基本的锁，也是最常用的锁之一。它可以保证在同一时间只有一个线程访问共享资源，因此是一种安全可靠的锁机制。但是，使用互斥锁时需要注意锁的粒度，如果锁的粒度过细，会导致线程频繁地抢占锁资源，从而降低程序的性能。在 iOS 中，可以使用 NSLock 和 pthread_mutex_t</p>\",\"autoDesc\":true}")

if (import.meta.webpackHot) {
  import.meta.webpackHot.accept()
  if (__VUE_HMR_RUNTIME__.updatePageData) {
    __VUE_HMR_RUNTIME__.updatePageData(data)
  }
}

if (import.meta.hot) {
  import.meta.hot.accept(({ data }) => {
    __VUE_HMR_RUNTIME__.updatePageData(data)
  })
}
